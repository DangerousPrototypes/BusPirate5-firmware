#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "pirate.h"
#include "system_config.h"
#include "command_struct.h"
#include "fatfs/ff.h"
#include "pirate/file.h"
#include "ui/ui_prompt.h"
#include "ui/ui_parse.h"
#include "ui/ui_term.h"
#include "ui/ui_help.h"
#include "pirate/storage.h"
#include "pirate/mem.h"
#include "ui/ui_cmdln.h"
//#include "pirate/storage.h"
#include "ui/ui_hex.h"
//#include "monster_builder.h" // Generated by `flatcc`.
#include "bpio_builder.h" // Generated by `flatcc`.
#include "bytecode.h"
#include "modes.h"

// Convenient namespace macro to manage long namespace prefix.
#undef ns
// Specified in the schema.
//#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(MyGame_Sample, x) 
#define ns_bpio(x) FLATBUFFERS_WRAP_NAMESPACE(BPIO2, x)

// A helper to simplify creating vectors from C-arrays.
#define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))

// This allows us to verify result in optimized builds.
#define test_assert(x) do { if (!(x)) { assert(0); return -1; }} while(0)

enum PacketType{
  I2CRWRequest = 0, // I2C Read/Write Request
  I2CResponse = 1, // I2C Response
  StatusRequest, 
  StatusResponse
};

int read_flat(const void *buffer){
    // get data out of flatbuffer, print it
    ns_bpio(Packet_table_t) packet = ns_bpio(Packet_as_root(buffer));
    // Make sure the packet is accessible.
    test_assert(packet != 0);
    //uint8_t packet_type = ns_bpio(Packet_type(packet));
    uint8_t packet_type = ns_bpio(Packet_contents_type(packet));
    printf("Packet Type: %d\r\n", packet_type);
    if(packet_type==I2CRWRequest){
        ns_bpio(I2CRWRequest_table_t) i2c_rw_request = (ns_bpio(I2CRWRequest_table_t)) ns_bpio(Packet_contents(packet));
        bool start = ns_bpio(I2CRWRequest_i2cstart(i2c_rw_request));
        uint8_t addr = ns_bpio(I2CRWRequest_i2caddr(i2c_rw_request));
        // Get the data vector.
        //ns_bpio(uint8_t_vec_t) data = ns_bpio(Bpio_i2cdata(bpio));
        uint32_t readbytes = ns_bpio(I2CRWRequest_i2creadbytes(i2c_rw_request));
        bool stop = ns_bpio(I2CRWRequest_i2cstop(i2c_rw_request));
        printf("Start: %s, Address: 0x%02X, Read Bytes: %d, Stop: %s\r\n",
               start ? "true" : "false", addr, readbytes, stop ? "true" : "false");
    }
}

int read_modes(const void *buffer) {
    // get data out of flatbuffer, print it
    ns_bpio(Packet_table_t) packet = ns_bpio(Packet_as_root(buffer));
    // Make sure the packet is accessible.
    test_assert(packet != 0);
    uint8_t packet_type = ns_bpio(Packet_contents_type(packet));
    printf("Packet Type: %d\r\n", packet_type);
    if(packet_type==ns_bpio(PacketContents_StatusResponse)){
        //get the array of modes from the status response
        ns_bpio(StatusResponse_table_t) status_response = (ns_bpio(StatusResponse_table_t)) ns_bpio(Packet_contents(packet));
        // Make sure the status response is accessible.
        test_assert(status_response != 0);
        ns_bpio(Mode_vec_t) modes = ns_bpio(StatusResponse_modes(status_response));
        // Make sure the modes vector is accessible.
        test_assert(modes != 0);
        // Iterate through the modes vector and print each mode.
        for (size_t i = 0; i < ns_bpio(Mode_vec_len(modes)); i++) {
            ns_bpio(Mode_table_t) mode = BPIO2_Mode_vec_at(modes, i);
            uint8_t id = ns_bpio(Mode_id(mode));
            const char* name = ns_bpio(Mode_name(mode));
            printf("Mode %zu: id=%d, name=%s\r\n", i, id, name ? name : "NULL");
        }
    }
    return 0;
}

void flat_handler(struct command_result* res) {
    uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    size_t data_size = c_vec_len(data);
    flatcc_builder_t builder, *B;
    B = &builder;
    flatcc_builder_init(B);


            printf("Sending list of modes\r\n");
            // send a list of modes back
ns_bpio(StatusResponse_start(B));
ns_bpio(StatusResponse_modes_start(B));
for (uint8_t i = 0; i < count_of(modes); i++) {
    flatbuffers_string_ref_t name = flatbuffers_string_create_str(B, modes[i].protocol_name);
    ns_bpio(StatusResponse_modes_push_create(B, i, name));
}            
ns_bpio(StatusResponse_modes_end(B));
BPIO2_StatusResponse_ref_t status_response = ns_bpio(StatusResponse_end(B));
    // add to packet wrapper
ns_bpio(Packet_start_as_root(B));
BPIO2_Packet_contents_StatusResponse_add(B, status_response);
//BPIO2_Packet_type_add(B, ns_bpio(PacketContents_StatusResponse)); // Set the packet type to StatusResponse.
ns_bpio(Packet_end_as_root(B));            
// send the packet
uint8_t* buf;
size_t len = flatcc_builder_get_buffer_size(B);
buf = flatcc_builder_finalize_buffer(B, &len);
            printf("Sending StatusResponse packet with length %d\r\n", len);

            read_modes(buf);

        return;

#if 0
#if 0
    ns_bpio(Packet_start_as_root(B));
    ns_bpio(Packet_contents_start(B));
    ns_bpio(Packet_contents_type_add(B, ns_bpio(PacketContents_I2CRWRequest))); // Set the packet contents type to I2CRWRequest.
    // alternate approach
    ns_bpio(I2CRWRequest_start(B));
    ns_bpio(I2CRWRequest_i2caddr_add(B, 0x50)); // Set the I2C address.
    ns_bpio(I2CRWRequest_i2cstart_add(B, true)); // Set the start condition.
    ns_bpio(I2CRWRequest_i2cstop_add(B, true)); //   Set the stop condition.
    ns_bpio(I2CRWRequest_i2cdata_create(B, data, c_vec_len(data))); // Set the payload data.
    ns_bpio(I2CRWRequest_i2creadbytes_add(B, 10)); // Set the number of bytes to read.
    ns_bpio(I2CRWRequest_end(B));
    // Create a packet with the I2C request.
    ns_bpio(Packet_start(B));
    ns_bpio(Packet_contents_I2CRWRequest_add(B, ns_bpio(I2CRWRequest_clone(B, ns_bpio(I2CRWRequest_as_root(B)))))); // Add the I2C request to the packet.
    ns_bpio(Packet_end(B));
#else

    flatbuffers_bool_t start = true; // Start condition.
    uint8_t addr = 0x50; // Device address (Bus Pirate automatically will set read/write bit).

    flatbuffers_uint8_vec_ref_t payload = flatbuffers_uint8_vec_create(B, data, c_vec_len(data));
    uint32_t readbytes = 10; // Number of bytes to read.
    flatbuffers_bool_t stop = true; // Stop condition.
    ns_bpio(I2CRWRequest_ref_t) i2c_rw_request = ns_bpio(I2CRWRequest_create(B, start, addr, payload, readbytes, stop));

    ns_bpio(Packet_start_as_root(B));
    ns_bpio(Packet_contents_I2CRWRequest_add(B, i2c_rw_request));
    ns_bpio(Packet_end_as_root(B));
 #endif   
    uint8_t *buf;
    size_t size;
    buf = flatcc_builder_finalize_buffer(B, &size);
    
    printf("Flatbuffers buffer size: %zu bytes\r\n", size);
    if(read_flat(buf)==-1) {
        printf("Error reading flatbuffer.\r\n");
    } else {
        printf("Flatbuffer read successfully.\r\n");
    }
    free(buf);

    // Optionally reset builder to reuse builder without deallocating
    // internal stack and heap.
    #endif
    flatcc_builder_reset(B);
    // build next buffer.
    // ...
    // Cleanup.
    flatcc_builder_clear(B);         
}