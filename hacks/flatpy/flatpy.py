import flatbuffers
import serial
import struct

# Generated by `flatc`.
import bpio.ConfigurationRequest as ConfigurationRequest
import bpio.ConfigurationResponse as ConfigurationResponse
import bpio.DataRequest as DataRequest
import bpio.DataResponse as DataResponse
import bpio.ModeConfiguration as ModeConfiguration
import bpio.RequestPacket as RequestPacket
import bpio.RequestPacketContents as RequestPacketContents
import bpio.ResponsePacket as ResponsePacket
import bpio.ResponsePacketContents as ResponsePacketContents
import bpio.StatusRequest as StatusRequest
import bpio.StatusRequestTypes as StatusRequestTypes
import bpio.StatusResponse as StatusResponse
import bpio.ErrorResponse as ErrorResponse

# Send to serial port and receive response
def send_and_receive(data):
    """Send data to serial port with 2-byte length header and receive response"""
    baudrate = 115200  # Default baudrate for BPIO
    try:
        length_header = struct.pack('<H', len(data))
        with serial.Serial(port, baudrate, timeout=2) as ser:
            print(f"Opened serial port {port} at {baudrate} baud")
            ser.write(length_header)
            ser.write(data)
            print(f"Sent {len(length_header)} bytes (length header): {length_header.hex()}")
            #print(f"Sent {len(data)} bytes (flatbuffer data): {data.hex()}")
            print(f"Sent {len(data)} bytes (flatbuffer data)")            
            print(f"Total bytes sent: {len(length_header) + len(data)}")

            # Read response length header (2 bytes)
            resp_len_bytes = ser.read(2)
            if len(resp_len_bytes) < 2:
                print("No response or incomplete length header received.")
                return None
            resp_len = struct.unpack('<H', resp_len_bytes)[0]
            print(f"Response length header: {resp_len_bytes.hex()} (value: {resp_len})")

            # Read response data
            resp_data = ser.read(resp_len)
            if len(resp_data) < resp_len:
                print("Incomplete response data received.")
                return None
            #print(f"Received {len(resp_data)} bytes (response data): {resp_data.hex()}")
            print(f"Received {len(resp_data)} bytes")
            # Decode response packet
            resp_packet = ResponsePacket.ResponsePacket.GetRootAsResponsePacket(resp_data, 0)
            contents_type = resp_packet.ContentsType()
            print(f"ContentsType: {contents_type}")
            if contents_type == ResponsePacketContents.ResponsePacketContents.ErrorResponse:
                error_resp = ErrorResponse.ErrorResponse()
                error_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)       
                print(f"  Error: {error_resp.Error().decode('utf-8')}")
                return None

            return resp_packet

    except serial.SerialException as e:
        print(f"Serial port error: {e}")
        print("Make sure the serial port exists and is not in use by another application")
    except Exception as e:
        print(f"Error: {e}")

# Show what would be sent over serial
def show_serial_data(data):
    """Display the serial data format without actually sending"""
    length_header = struct.pack('<H', len(data))
    total_data = length_header + data

    print(f"\nSerial data format:")
    print(f"Length header (2 bytes): {length_header.hex()} (value: {len(data)})")
    print(f"FlatBuffer data ({len(data)} bytes): {data.hex()}")
    print(f"Complete packet ({len(total_data)} bytes): {total_data.hex()}")

    return total_data

def bpio_wrap_request(builder, contents_type, contents):
    """Wrap contents in a RequestPacket"""
    #builder = flatbuffers.Builder(1024)
    RequestPacket.Start(builder)
    RequestPacket.AddContentsType(builder, contents_type)
    RequestPacket.AddContents(builder, contents)
    final_packet = RequestPacket.End(builder)
    builder.Finish(final_packet)
    return builder.Output()

def bpio_status_request():
    """Create a BPIO StatusRequest packet"""
    builder = flatbuffers.Builder(1024)

    # Create the query vector BEFORE starting the StatusRequest table
    StatusRequest.StartQueryVector(builder, 2)
    builder.PrependUint8(StatusRequestTypes.StatusRequestTypes.All)
    builder.PrependUint8(StatusRequestTypes.StatusRequestTypes.Version)
    query_vector = builder.EndVector()

    # Create a StatusRequest
    StatusRequest.Start(builder)
    StatusRequest.AddQuery(builder, query_vector)
    status_request = StatusRequest.End(builder)
    data = bpio_wrap_request(builder, RequestPacketContents.RequestPacketContents.StatusRequest, status_request)
    resp_packet = send_and_receive(data)
    
    #test packet type and error field
    contents_type = resp_packet.ContentsType()
    if contents_type != ResponsePacketContents.ResponsePacketContents.StatusResponse:
        print(f"Expected StatusResponse, got {contents_type}")
        return None
    status_resp = StatusResponse.StatusResponse()
    status_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
    print("StatusResponse:")
    
    # Print hardware and firmware versions, test if fields are present
    print(f"  Hardware version: {status_resp.HardwareVersionMajor()} REV{status_resp.HardwareVersionMinor()}")
    print(f"  Firmware version: {status_resp.FirmwareVersionMajor()}.{status_resp.FirmwareVersionMinor()}")
    print(f"  Firmware git hash: {status_resp.FirmwareGitHash().decode('utf-8')}")
    print(f"  Firmware date: {status_resp.FirmwareDate().decode('utf-8')}")

    # Print all modes in one line using list comprehension
    # test if modes field is present
    if status_resp.ModesAvailableLength():
        modes = [status_resp.ModesAvailable(i).decode('utf-8') for i in range(status_resp.ModesAvailableLength())]
        print(f"  Available modes: {', '.join(modes)}")

    # Print current mode
    if status_resp.ModeCurrent():
        print(f"  Current mode: {status_resp.ModeCurrent().decode('utf-8')}")

    # Print mode bit order 
    print(f"  Mode bit order: {"MSB" if status_resp.ModeBitorderMsb() else "LSB"}")

    # pin labels
    if status_resp.ModePinLabelsLength():
        pin_labels = [status_resp.ModePinLabels(i).decode('utf-8') for i in range(status_resp.ModePinLabelsLength())]
        print(f"  Pin labels: {', '.join(pin_labels)}")

    # Print LED count
    if status_resp.LedCount():
        print(f"  Number of LEDs: {status_resp.LedCount()}")

    # Print pull-up resistor status
    print(f"  Pull-up resistors enabled: {status_resp.PullupEnabled()}")

    # Print power supply information
    print(f"  Power supply enabled: {status_resp.PsuEnabled()}")
    print(f"  PSU set voltage: {status_resp.PsuSetMv()} mV")
    print(f"  PSU set current: {status_resp.PsuSetMa()} mA")
    print(f"  PSU measured voltage: {status_resp.PsuMeasuredMv()} mV")
    print(f"  PSU measured current: {status_resp.PsuMeasuredMa()} mA")        
    print(f"  PSU over current error: {"Yes" if status_resp.PsuCurrentError() else "No"}")

    # Print ADC values
    if status_resp.AdcMvLength():
        adc_values = [str(status_resp.AdcMv(i)) for i in range(status_resp.AdcMvLength())]
        print(f"  IO ADC values (mV): {', '.join(adc_values)}")

    # Print IO pin directions (single byte representing 8 pins)
    # NOTE: there is no way in the python tooling to know if this was actually sent, so the user should make sure the correct query was sent
    io_direction_byte = status_resp.IoDirection()
    directions = []
    for i in range(8):
        bit_value = (io_direction_byte >> i) & 1
        direction = 'OUT' if bit_value else 'IN'
        directions.append(f"IO{i}:{direction}")
    print(f"  IO directions: {', '.join(directions)}")

    # Print IO pin values
    io_value_byte = status_resp.IoValue()
    values = []
    for i in range(8):
        bit_value = (io_value_byte >> i) & 1
        value = 'HIGH' if bit_value else 'LOW'
        values.append(f"IO{i}:{value}")
    print(f"  IO values: {', '.join(values)}")

    # Print disk information
    print(f"  Disk size: {status_resp.DiskSizeMb()} MB")
    print(f"  Disk space used: {status_resp.DiskUsedMb()} MB")


def bpio_configuration_request(mode, speed):
    """Create a BPIO ConfigurationRequest packet"""
    builder = flatbuffers.Builder(1024)
    mode = builder.CreateString(mode)
    print_string = builder.CreateString("Test print to terminal\r\n")

    # Create LED colors (RGB format)
    # A vector of 18 RGB LED colors, each represented as a 32-bit integer (0xRRGGBB)
    led_colors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF] * 3
    #led_colors = [0x000000] * 18  # Example: all LEDs off (black)
    ConfigurationRequest.StartLedColorVector(builder, 18)
    for color in reversed(led_colors):
        builder.PrependUint32(color)
    led_color_vector = builder.EndVector()

    # Create a ModeConfiguration
    ModeConfiguration.Start(builder)
    ModeConfiguration.AddSpeed(builder, speed)  # Speed in Hz
    ModeConfiguration.AddClockStretch(builder, False)  # Example: clock stretching disabled
    mode_config = ModeConfiguration.End(builder)

    # Create a ConfigurationRequest
    ConfigurationRequest.Start(builder)
    ConfigurationRequest.AddMode(builder, mode)
    ConfigurationRequest.AddModeConfiguration(builder, mode_config)
    
    # populate all ConfigurationRequest fields
    ConfigurationRequest.AddModeBitorderMsb(builder, True)  # Example: MSB first
    #ConfigurationRequest.AddModeBitorderLsb(builder, True)  # Example: LSB last
    ConfigurationRequest.AddPullupDisable(builder, True)  # Example: pull-up resistors disabled
    ConfigurationRequest.AddPullupEnable(builder, True)  # Example: pull-up resistors enabled
    ConfigurationRequest.AddPsuDisable(builder, True)  # Example: PSU disabled
    ConfigurationRequest.AddPsuEnable(builder, True)  # Example: PSU enabled
    ConfigurationRequest.AddPsuSetMv(builder, 3300)  # Example: 3.3V
    ConfigurationRequest.AddPsuSetMa(builder, 0)  # Example: 500mA
    #ConfigurationRequest.AddIoDirectionMask(builder, 255)  # Example: all pins as outputs
    #ConfigurationRequest.AddIoDirection(builder, 0)
    #ConfigurationRequest.AddIoValueMask(builder, 255)  # Example: all pins set to HIGH
    #ConfigurationRequest.AddIoValue(builder, 0)
    
    ConfigurationRequest.AddLedColor(builder, led_color_vector)
    #ConfigurationRequest.AddLedResume(builder, True)  # Example: resume LED blinking

    ConfigurationRequest.AddPrintString(builder, print_string)  # Example: print configuration string

    #ConfigurationRequest.AddHardwareBootloader(builder, True)  # Example: hardware bootloader enabled
    #ConfigurationRequest.AddHardwareReset(builder, True)  # Example: hardware reset enabled

    config_request = ConfigurationRequest.End(builder)

    data = bpio_wrap_request(builder, RequestPacketContents.RequestPacketContents.ConfigurationRequest, config_request)
    resp_packet = send_and_receive(data)

    # Check response type
    contents_type = resp_packet.ContentsType()
    if contents_type != ResponsePacketContents.ResponsePacketContents.ConfigurationResponse:
        print(f"Expected ConfigurationResponse, got {contents_type}")
        return None

    #get the ConfigurationResponse
    config_resp = ConfigurationResponse.ConfigurationResponse()
    config_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
    #is error field present?
    if config_resp.Error():
        print(f"Configuration error: {config_resp.Error().decode('utf-8')}")


def bpio_data_request(start_main, start_alt, data_write, bytes_read, stop_main, stop_alt):
    """Create a BPIO DataRequest packet"""
    builder = flatbuffers.Builder(1024)

    data_write_vector = builder.CreateByteVector(bytes(data_write))

    # Create a DataRequest
    DataRequest.Start(builder)
    if start_main:
        DataRequest.AddStartMain(builder, True)
    if start_alt:
        DataRequest.AddStartAlt(builder, True)
    if len(data_write) > 0:
        DataRequest.AddDataWrite(builder, data_write_vector)
    if bytes_read > 0:
        DataRequest.AddBytesRead(builder, bytes_read)
    if stop_main:
        DataRequest.AddStopMain(builder, True)
    if stop_alt:
        DataRequest.AddStopAlt(builder, True)

    data_request = DataRequest.End(builder)
    data = bpio_wrap_request(builder, RequestPacketContents.RequestPacketContents.DataRequest, data_request)
    resp_packet = send_and_receive(data)
    
    # Check response type
    contents_type = resp_packet.ContentsType()
    if contents_type != ResponsePacketContents.ResponsePacketContents.DataResponse:
        print(f"Expected DataResponse, got {contents_type}")
        return None
    
    #get the DataResponse
    data_resp = DataResponse.DataResponse()
    data_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
    
    # Check if error field is present
    if data_resp.Error():
        print(f"Data request error: {data_resp.Error().decode('utf-8')}")

    # print the data read, if any
    if data_resp.DataReadLength() > 0:
        data_bytes = data_resp.DataReadAsNumpy()
        print(f"Data read: {' '.join(f'{b:02x}' for b in data_bytes)}")

#for i in range(100):
#    print(f"***********************Test {i+1}:")
port='COM35'
bpio_status_request()
# 1WIRE example
if True:
    bpio_configuration_request("1WIRE", 100000)
    bpio_data_request(True, False, [0xcc, 0x4e, 0x00, 0x00, 0x7f], 0, False, False)
    bpio_data_request(True, False, [0xcc, 0x44], 0, False, False)
    # delay 800ms to allow the device to process the command
    import time
    time.sleep(0.8)
    bpio_data_request(True, False, [0xcc, 0xbe], 9, False, False)  # Read 9 bytes
# I2C example
if False:
    bpio_configuration_request("I2C", 400000)
    bpio_data_request(True, False, [0xA0, 0x00], 16, True, False)
# SPI example
if False:
    bpio_configuration_request("SPI", 100000)
    bpio_data_request(True, False, [0x9f], 3, True, False)