import flatbuffers
import serial
import struct

# Generated by `flatc`.
import bpio.ConfigurationRequest as ConfigurationRequest
import bpio.ConfigurationResponse as ConfigurationResponse
import bpio.DataRequest as DataRequest
import bpio.DataResponse as DataResponse
import bpio.ModeConfiguration as ModeConfiguration
import bpio.RequestPacket as RequestPacket
import bpio.RequestPacketContents as RequestPacketContents
import bpio.ResponsePacket as ResponsePacket
import bpio.ResponsePacketContents as ResponsePacketContents
import bpio.StatusRequest as StatusRequest
import bpio.StatusRequestTypes as StatusRequestTypes
import bpio.StatusResponse as StatusResponse
import bpio.ErrorResponse as ErrorResponse

class BPIOClient:
    def __init__(self, port, baudrate=115200, timeout=2, debug=False):
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.debug = debug
        self.serial_port = None
        
        # Open serial port
        try:
            self.serial_port = serial.Serial(self.port, self.baudrate, timeout=self.timeout)
            if self.debug:
                print(f"Opened serial port {self.port} at {self.baudrate} baud")
        except serial.SerialException as e:
            print(f"Failed to open serial port {self.port}: {e}")
            print("Make sure the serial port exists and is not in use by another application")
            raise
        except Exception as e:
            print(f"Error opening serial port: {e}")
            raise
    
    def __enter__(self):
        """Context manager entry"""
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.close()
    
    def close(self):
        """Close the serial port"""
        if self.serial_port and self.serial_port.is_open:
            self.serial_port.close()
            if self.debug:
                print(f"Closed serial port {self.port}")
    
    def __del__(self):
        """Destructor - ensure port is closed"""
        self.close()
        
    def send_and_receive(self, data):
        """Send data to serial port with 2-byte length header and receive response"""
        if not self.serial_port or not self.serial_port.is_open:
            print("Serial port is not open")
            return None
            
        try:
            length_header = struct.pack('<H', len(data))
            
            # Clear any pending data
            self.serial_port.reset_input_buffer()
            self.serial_port.reset_output_buffer()
            
            # Send data
            self.serial_port.write(length_header)
            self.serial_port.write(data)
            
            if self.debug:
                print(f"Sent {len(length_header)} bytes (length header): {length_header.hex()}")
                print(f"Sent {len(data)} bytes (flatbuffer data)")            
                print(f"Total bytes sent: {len(length_header) + len(data)}")

            # Read response length header (2 bytes)
            resp_len_bytes = self.serial_port.read(2)
            if len(resp_len_bytes) < 2:
                print("No response or incomplete length header received.")
                return None
            resp_len = struct.unpack('<H', resp_len_bytes)[0]
            if self.debug:
                print(f"Response length header: {resp_len_bytes.hex()} (value: {resp_len})")

            # Read response data
            resp_data = self.serial_port.read(resp_len)
            if len(resp_data) < resp_len:
                print("Incomplete response data received.")
                return None
            if self.debug:
                print(f"Received {len(resp_data)} bytes")
            
            # Decode response packet
            resp_packet = ResponsePacket.ResponsePacket.GetRootAsResponsePacket(resp_data, 0)
            contents_type = resp_packet.ContentsType()
            if self.debug:
                print(f"ContentsType: {contents_type}")
            
            if contents_type == ResponsePacketContents.ResponsePacketContents.ErrorResponse:
                error_resp = ErrorResponse.ErrorResponse()
                error_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)       
                print(f"  Error: {error_resp.Error().decode('utf-8')}")
                return None

            return resp_packet

        except serial.SerialException as e:
            print(f"Serial communication error: {e}")
        except Exception as e:
            print(f"Error: {e}")
        return None

    def _wrap_request(self, builder, contents_type, contents):
        """Wrap contents in a RequestPacket"""
        RequestPacket.Start(builder)
        RequestPacket.AddContentsType(builder, contents_type)
        RequestPacket.AddContents(builder, contents)
        final_packet = RequestPacket.End(builder)
        builder.Finish(final_packet)
        return builder.Output()

    def status_request(self):
        """Create a BPIO StatusRequest packet"""
        builder = flatbuffers.Builder(1024)

        # Create the query vector BEFORE starting the StatusRequest table
        StatusRequest.StartQueryVector(builder, 2)
        builder.PrependUint8(StatusRequestTypes.StatusRequestTypes.All)
        builder.PrependUint8(StatusRequestTypes.StatusRequestTypes.Version)
        query_vector = builder.EndVector()

        # Create a StatusRequest
        StatusRequest.Start(builder)
        StatusRequest.AddQuery(builder, query_vector)
        status_request = StatusRequest.End(builder)
        data = self._wrap_request(builder, RequestPacketContents.RequestPacketContents.StatusRequest, status_request)
        resp_packet = self.send_and_receive(data)
        
        if not resp_packet:
            return None
            
        contents_type = resp_packet.ContentsType()
        if contents_type != ResponsePacketContents.ResponsePacketContents.StatusResponse:
            print(f"Expected StatusResponse, got {contents_type}")
            return None
            
        status_resp = StatusResponse.StatusResponse()
        status_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
        return self._parse_status_response(status_resp)

    def _parse_status_response(self, status_resp):
        """Parse and display status response"""
        print("StatusResponse:")
        print(f"  Hardware version: {status_resp.HardwareVersionMajor()} REV{status_resp.HardwareVersionMinor()}")
        print(f"  Firmware version: {status_resp.FirmwareVersionMajor()}.{status_resp.FirmwareVersionMinor()}")
        print(f"  Firmware git hash: {status_resp.FirmwareGitHash().decode('utf-8')}")
        print(f"  Firmware date: {status_resp.FirmwareDate().decode('utf-8')}")

        if status_resp.ModesAvailableLength():
            modes = [status_resp.ModesAvailable(i).decode('utf-8') for i in range(status_resp.ModesAvailableLength())]
            print(f"  Available modes: {', '.join(modes)}")

        if status_resp.ModeCurrent():
            print(f"  Current mode: {status_resp.ModeCurrent().decode('utf-8')}")

        print(f"  Mode bit order: {"MSB" if status_resp.ModeBitorderMsb() else "LSB"}")

        if status_resp.ModePinLabelsLength():
            pin_labels = [status_resp.ModePinLabels(i).decode('utf-8') for i in range(status_resp.ModePinLabelsLength())]
            print(f"  Pin labels: {', '.join(pin_labels)}")

        if status_resp.LedCount():
            print(f"  Number of LEDs: {status_resp.LedCount()}")

        print(f"  Pull-up resistors enabled: {status_resp.PullupEnabled()}")
        print(f"  Power supply enabled: {status_resp.PsuEnabled()}")
        print(f"  PSU set voltage: {status_resp.PsuSetMv()} mV")
        print(f"  PSU set current: {status_resp.PsuSetMa()} mA")
        print(f"  PSU measured voltage: {status_resp.PsuMeasuredMv()} mV")
        print(f"  PSU measured current: {status_resp.PsuMeasuredMa()} mA")        
        print(f"  PSU over current error: {"Yes" if status_resp.PsuCurrentError() else "No"}")

        if status_resp.AdcMvLength():
            adc_values = [str(status_resp.AdcMv(i)) for i in range(status_resp.AdcMvLength())]
            print(f"  IO ADC values (mV): {', '.join(adc_values)}")

        # Print IO pin directions and values
        io_direction_byte = status_resp.IoDirection()
        directions = []
        for i in range(8):
            bit_value = (io_direction_byte >> i) & 1
            direction = 'OUT' if bit_value else 'IN'
            directions.append(f"IO{i}:{direction}")
        print(f"  IO directions: {', '.join(directions)}")

        io_value_byte = status_resp.IoValue()
        values = []
        for i in range(8):
            bit_value = (io_value_byte >> i) & 1
            value = 'HIGH' if bit_value else 'LOW'
            values.append(f"IO{i}:{value}")
        print(f"  IO values: {', '.join(values)}")

        print(f"  Disk size: {status_resp.DiskSizeMb()} MB")
        print(f"  Disk space used: {status_resp.DiskUsedMb()} MB")
        
        return status_resp

    def configure_mode(self, mode, speed=100000, **kwargs):
        """Configure a mode with given parameters"""
        builder = flatbuffers.Builder(1024)
        mode_str = builder.CreateString(mode)
        
        print_string = kwargs.get('print_string', "Mode configured\r\n")
        print_string = builder.CreateString(print_string)

        # Create LED colors if provided
        led_color_vector = None
        if 'led_colors' in kwargs:
            led_colors = kwargs['led_colors']
            ConfigurationRequest.StartLedColorVector(builder, len(led_colors))
            for color in reversed(led_colors):
                builder.PrependUint32(color)
            led_color_vector = builder.EndVector()

        # Create a ModeConfiguration
        ModeConfiguration.Start(builder)
        ModeConfiguration.AddSpeed(builder, speed)
        
        # Add mode-specific configuration
        if 'clock_stretch' in kwargs:
            ModeConfiguration.AddClockStretch(builder, kwargs['clock_stretch'])
        if 'clock_polarity' in kwargs:
            ModeConfiguration.AddClockPolarity(builder, kwargs['clock_polarity'])
        if 'clock_phase' in kwargs:
            ModeConfiguration.AddClockPhase(builder, kwargs['clock_phase'])
        if 'chip_select_idle' in kwargs:
            ModeConfiguration.AddChipSelectIdle(builder, kwargs['chip_select_idle'])
            
        mode_config = ModeConfiguration.End(builder)

        # Create a ConfigurationRequest
        ConfigurationRequest.Start(builder)
        ConfigurationRequest.AddMode(builder, mode_str)
        ConfigurationRequest.AddModeConfiguration(builder, mode_config)
        
        # Add optional configuration parameters
        if 'bit_order_msb' in kwargs:
            ConfigurationRequest.AddModeBitorderMsb(builder, kwargs['bit_order_msb'])
        if 'pullup_enable' in kwargs:
            ConfigurationRequest.AddPullupEnable(builder, kwargs['pullup_enable'])
        if 'pullup_disable' in kwargs:
            ConfigurationRequest.AddPullupDisable(builder, kwargs['pullup_disable'])
        if 'psu_enable' in kwargs:
            ConfigurationRequest.AddPsuEnable(builder, kwargs['psu_enable'])
        if 'psu_disable' in kwargs:
            ConfigurationRequest.AddPsuDisable(builder, kwargs['psu_disable'])
        if 'psu_voltage_mv' in kwargs:
            ConfigurationRequest.AddPsuSetMv(builder, kwargs['psu_voltage_mv'])
        if 'psu_current_ma' in kwargs:
            ConfigurationRequest.AddPsuSetMa(builder, kwargs['psu_current_ma'])
            
        if led_color_vector:
            ConfigurationRequest.AddLedColor(builder, led_color_vector)
            
        ConfigurationRequest.AddPrintString(builder, print_string)

        config_request = ConfigurationRequest.End(builder)
        data = self._wrap_request(builder, RequestPacketContents.RequestPacketContents.ConfigurationRequest, config_request)
        resp_packet = self.send_and_receive(data)

        if not resp_packet:
            return False
            
        contents_type = resp_packet.ContentsType()
        if contents_type != ResponsePacketContents.ResponsePacketContents.ConfigurationResponse:
            print(f"Expected ConfigurationResponse, got {contents_type}")
            return False

        config_resp = ConfigurationResponse.ConfigurationResponse()
        config_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
        
        if config_resp.Error():
            print(f"Configuration error: {config_resp.Error().decode('utf-8')}")
            return False
            
        return True

    def data_request(self, start_main=False, start_alt=False, data_write=None, bytes_read=0, stop_main=False, stop_alt=False):
        """Create a BPIO DataRequest packet"""
        builder = flatbuffers.Builder(1024)

        data_write_vector = None
        if data_write and len(data_write) > 0:
            data_write_vector = builder.CreateByteVector(bytes(data_write))

        # Create a DataRequest
        DataRequest.Start(builder)
        if start_main:
            DataRequest.AddStartMain(builder, True)
        if start_alt:
            DataRequest.AddStartAlt(builder, True)
        if data_write_vector:
            DataRequest.AddDataWrite(builder, data_write_vector)
        if bytes_read > 0:
            DataRequest.AddBytesRead(builder, bytes_read)
        if stop_main:
            DataRequest.AddStopMain(builder, True)
        if stop_alt:
            DataRequest.AddStopAlt(builder, True)

        data_request = DataRequest.End(builder)
        data = self._wrap_request(builder, RequestPacketContents.RequestPacketContents.DataRequest, data_request)
        resp_packet = self.send_and_receive(data)
        
        if not resp_packet:
            return None
            
        contents_type = resp_packet.ContentsType()
        if contents_type != ResponsePacketContents.ResponsePacketContents.DataResponse:
            print(f"Expected DataResponse, got {contents_type}")
            return None
        
        data_resp = DataResponse.DataResponse()
        data_resp.Init(resp_packet.Contents().Bytes, resp_packet.Contents().Pos)
        
        if data_resp.Error():
            if self.debug: print(f"Data request error: {data_resp.Error().decode('utf-8')}")
            return None

        # Return data read, if any
        if data_resp.DataReadLength() > 0:
            data_bytes = data_resp.DataReadAsNumpy()
            if self.debug:  print(f"Data read: {' '.join(f'{b:02x}' for b in data_bytes)}")
            return data_bytes.tobytes()
            
        return b''