;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;
.pio_version 0 // only requires PIO version 0


.program rc5_carrier
.define public TICKS_PER_LOOP 2     ; the number of instructions in the loop (for timing)

.wrap_target
    set pins, 1                 ; set the pin high 
    set pins, 0                 ; set the pin low 
.wrap


% c-sdk {
static inline void rc5_carrier_program_init(PIO pio, uint sm, uint offset, uint pin, float freq) {
    // Create a new state machine configuration
    //
    pio_sm_config c = rc5_carrier_program_get_default_config (offset);

    // Map the SET pin group to one pin, namely the `pin`
    // parameter to this function.
    //
    sm_config_set_set_pins (&c, pin, 1);

    // Set the GPIO function of the pin (connect the PIO to the pad)
    //
    pio_gpio_init (pio, pin);

    // Set the pin direction to input at the PIO
    //
    pio_sm_set_consecutive_pindirs (pio, sm, pin, 1, false);

    // Set the clock divider to generate the required frequency
    //
    float div = clock_get_hz (clk_sys) / (freq * rc5_carrier_TICKS_PER_LOOP);
    sm_config_set_clkdiv (&c, div);

    // Apply the configuration to the state machine
    //
    pio_sm_init (pio, sm, offset, &c);

    // Set the state machine running
    //
    pio_sm_set_enabled (pio, sm, true);
}
%}

.program manchester_tx
.side_set 1 opt

; Transmit one bit every 12 cycles. a '0' is encoded as a high-low sequence
; (each part lasting half a bit period, or 6 cycles) and a '1' is encoded as a
; low-high sequence.
;
; Autopull must be enabled -- this program does not care about the threshold.
; The program starts at the public label 'start'.
.wrap_target
do_1:
    set pindirs, 0 [5]      ; Set pin as input (1 + 5 = 6 cycles low)
    set pindirs, 1 [2]      ; Set pin as output (1 + 2 + 1 + 2 = 6 cycles high)
    jmp get_bit             ; 
do_0:
    set pindirs, 1 [5]      ; Set pin as output (1 + 5 = 6 cycles high)
    set pindirs, 0 [2]      ; Set pin as input (1 + 2 + 1 + 2 = 6 cycles low)
public start:
get_bit:
    out x, 1               ; Always shift out one bit from OSR to X, so we can
    jmp !x do_0            ; branch on it. Autopull refills the OSR when empty.
.wrap

% c-sdk {
static inline void manchester_tx_program_init(PIO pio, uint sm, uint offset, uint pin, float div) {
    pio_sm_set_pins_with_mask(pio, sm, 0, 1u << pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);
    pio_gpio_init(pio, pin);

    pio_sm_config c = manchester_tx_program_get_default_config(offset);
    sm_config_set_set_pins(&c, pin, 1);
    sm_config_set_out_shift(&c, true, true, 32);
    sm_config_set_clkdiv(&c, div);
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}

.program manchester_rx

; Assumes line is idle low, first bit is 0
; One bit is 12 cycles
; a '0' is encoded as 10
; a '1' is encoded as 01
;
; Both the IN base and the JMP pin mapping must be pointed at the GPIO used for RX.
; Autopush must be enabled.
; Before enabling the SM, it should be placed in a 'wait 1, pin` state, so that
; it will not start sampling until the initial line idle state ends.

start_of_0:            ; We are 0.25 bits into a 0 - signal is high
    wait 0 pin 0       ; Wait for the 1->0 transition - at this point we are 0.5 into the bit
    in y, 1 [8]        ; Emit a 0, sleep 3/4 of a bit
    jmp pin start_of_0 ; If signal is 1 again, it's another 0 bit, otherwise it's a 1

.wrap_target
start_of_1:            ; We are 0.25 bits into a 1 - signal is 1   
    wait 1 pin 0       ; Wait for the 0->1 transition - at this point we are 0.5 into the bit
    in x, 1 [8]        ; Emit a 1, sleep 3/4 of a bit
    jmp pin start_of_0 ; If signal is 0 again, it's another 1 bit otherwise it's a 0
.wrap

% c-sdk {
static inline void manchester_rx_program_init(PIO pio, uint sm, uint offset, uint pin, float div) {
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
    pio_gpio_init(pio, pin);

    pio_sm_config c = manchester_rx_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin); // for WAIT
    sm_config_set_jmp_pin(&c, pin); // for JMP
    sm_config_set_in_shift(&c, true, true, 32);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    sm_config_set_clkdiv(&c, div);
    pio_sm_init(pio, sm, offset, &c);

    // X and Y are set to 0 and 1, to conveniently emit these to ISR/FIFO.
    pio_sm_exec(pio, sm, pio_encode_set(pio_x, 1));
    pio_sm_exec(pio, sm, pio_encode_set(pio_y, 0));
    // Assume line is idle low, and first transmitted bit is 0. Put SM in a
    // wait state before enabling. RX will begin once the first 0 symbol is
    // detected.
    pio_sm_exec(pio, sm, pio_encode_wait_pin(1, 0) | pio_encode_delay(2));
    pio_sm_set_enabled(pio, sm, true);
}
%}
