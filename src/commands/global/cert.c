// TODO: BIO use, pullups, psu
/*
    Welcome to dummy.c, a growing demonstration of how to add commands to the Bus Pirate firmware.
    You can also use this file as the basis for your own commands.
    Type "dummy" at the Bus Pirate prompt to see the output of this command
    Temporary info available at https://forum.buspirate.com/t/command-line-parser-for-developers/235
*/
#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "pirate.h"
#include "command_struct.h"       // File system related
#include "fatfs/ff.h"       // File system related
#include "pirate/storage.h" // File system related
#include "ui/ui_cmdln.h"    // This file is needed for the command line parsing functions
// #include "ui/ui_prompt.h" // User prompts and menu system
// #include "ui/ui_const.h"  // Constants and strings
#include "ui/ui_help.h"    // Functions to display help in a standardized way
#include "system_config.h" // Stores current Bus Pirate system configuration
#include "pirate/amux.h"   // Analog voltage measurement functions
#include "pirate/button.h" // Button press functions
#include "msc_disk.h"
#include "mbedtls/x509_crt.h"
#include "mbedtls/pk.h"
#include "mbedtls/error.h"
#include "mbedtls/md_internal.h"
#include "mbedtls/oid.h"
#include "cert.h"
#include "mbedtls/md.h"
#include "mbedtls/pem.h"
#include "pico/unique_id.h"

#if 0 //2048 key
unsigned const char cert_der[] = { 0x30, 0x82, 0x03, 0xaa, 0x30, 0x82, 0x02, 0x92, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x13, 0x37, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x69, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x04, 0x49, 0x6f, 0x77, 0x61, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x09, 0x4d, 0x75, 0x73, 0x63, 0x61, 0x74, 0x69, 0x6e, 0x65, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0e, 0x57, 0x68, 0x65, 0x72, 0x65, 0x20, 0x4c, 0x61, 0x62, 0x73, 0x20, 0x4c, 0x4c, 0x43, 0x31, 0x1e, 0x30, 0x1c, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x15, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x62, 0x75, 0x73, 0x70, 0x69, 0x72, 0x61, 0x74, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x20, 0x17, 0x0d, 0x32, 0x35, 0x30, 0x32, 0x30, 0x34, 0x31, 0x35, 0x30, 0x36, 0x35, 0x37, 0x5a, 0x18, 0x0f, 0x32, 0x31, 0x32, 0x35, 0x30, 0x31, 0x31, 0x31, 0x31, 0x35, 0x30, 0x36, 0x35, 0x37, 0x5a, 0x30, 0x5b, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x09, 0x47, 0x75, 0x61, 0x6e, 0x67, 0x64, 0x6f, 0x6e, 0x67, 0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x08, 0x53, 0x68, 0x65, 0x6e, 0x7a, 0x68, 0x65, 0x6e, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0c, 0x42, 0x75, 0x73, 0x20, 0x50, 0x69, 0x72, 0x61, 0x74, 0x65, 0x20, 0x36, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x05, 0x52, 0x65, 0x76, 0x20, 0x32, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xdb, 0x82, 0x15, 0x81, 0x99, 0x84, 0x00, 0xba, 0x20, 0x2b, 0x37, 0x06, 0x49, 0xc9, 0xec, 0x50, 0x27, 0x4a, 0xb0, 0x8d, 0xd7, 0x82, 0x38, 0xb0, 0x3b, 0x50, 0x99, 0x93, 0x5d, 0xe4, 0x86, 0x58, 0x56, 0xed, 0x19, 0xf3, 0x55, 0x7a, 0x87, 0x3a, 0x75, 0x62, 0x3f, 0x4b, 0x30, 0xcd, 0xd8, 0xee, 0x0f, 0x25, 0xf2, 0x60, 0x38, 0x13, 0x64, 0x10, 0x80, 0x85, 0x40, 0xc4, 0xe6, 0xd8, 0xa7, 0x8c, 0x07, 0x0e, 0x8c, 0x63, 0xe4, 0x6a, 0x6e, 0xf3, 0xfe, 0x76, 0x8b, 0x00, 0xdf, 0xbb, 0x55, 0x18, 0x46, 0x5f, 0x17, 0x21, 0xd1, 0xd1, 0xa6, 0x8f, 0x1f, 0xe6, 0x99, 0xd4, 0xc1, 0x5a, 0x77, 0x8a, 0xb5, 0x32, 0x7e, 0xf0, 0x99, 0x91, 0x07, 0x0f, 0x3c, 0x4e, 0x70, 0xe3, 0x19, 0xb1, 0xb3, 0xae, 0x4e, 0xc8, 0x38, 0x8c, 0xd2, 0x22, 0xd0, 0x3d, 0x1f, 0x07, 0x79, 0xf8, 0x52, 0x05, 0x15, 0x13, 0x66, 0x19, 0x92, 0x55, 0x64, 0x4b, 0x8f, 0xb5, 0x08, 0xaa, 0x00, 0xf0, 0xcd, 0x8c, 0x68, 0x72, 0x4e, 0xff, 0xdd, 0xe1, 0xf6, 0x25, 0xec, 0x31, 0x80, 0xdb, 0xff, 0x62, 0xc0, 0xb1, 0x22, 0x15, 0xab, 0x52, 0x1c, 0x40, 0x2a, 0x37, 0x11, 0x75, 0x05, 0x73, 0x33, 0x39, 0x9e, 0x94, 0xe2, 0x43, 0xd0, 0xbf, 0xd1, 0x9d, 0x4d, 0xd2, 0x30, 0x7c, 0x52, 0x85, 0x21, 0xa7, 0x29, 0x7d, 0xaf, 0xb9, 0x34, 0x4e, 0x9a, 0x27, 0x1e, 0x52, 0x3b, 0x0c, 0x2d, 0x66, 0x69, 0x4f, 0xde, 0x5e, 0x0e, 0x82, 0xff, 0x90, 0x2f, 0x5d, 0x28, 0x70, 0x19, 0x99, 0x07, 0xaf, 0xf6, 0x83, 0x3a, 0xfa, 0xf2, 0x7b, 0x7e, 0x2d, 0x92, 0x7a, 0xa3, 0xa0, 0xdc, 0x17, 0xab, 0x60, 0x74, 0x6b, 0x69, 0x99, 0x10, 0x21, 0xad, 0x22, 0xf7, 0xda, 0x95, 0x8d, 0x43, 0xb7, 0xb4, 0x47, 0x1e, 0xc4, 0xb2, 0x4d, 0xee, 0x4d, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x68, 0x30, 0x66, 0x30, 0x20, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0xd6, 0x79, 0x02, 0x01, 0x01, 0x04, 0x12, 0x42, 0x50, 0x20, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x20, 0x42, 0x50, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x30, 0x21, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0xd6, 0x79, 0x02, 0x01, 0x02, 0x04, 0x13, 0x72, 0x50, 0x49, 0x20, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x20, 0x52, 0x50, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x30, 0x1f, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0xd6, 0x79, 0x02, 0x01, 0x03, 0x04, 0x11, 0x4d, 0x46, 0x47, 0x20, 0x64, 0x61, 0x74, 0x65, 0x20, 0x32, 0x30, 0x32, 0x33, 0x30, 0x31, 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x33, 0x29, 0x87, 0x35, 0xf6, 0x64, 0x36, 0x0d, 0x69, 0xcd, 0x97, 0x18, 0x8f, 0xae, 0x42, 0xb5, 0x2c, 0x10, 0x4e, 0xc0, 0x06, 0x66, 0x91, 0xe9, 0x05, 0x3c, 0x08, 0x9b, 0xdf, 0x7d, 0xaa, 0x27, 0xdf, 0x4f, 0xce, 0xff, 0xc5, 0x64, 0xba, 0x77, 0x2c, 0x04, 0x32, 0x52, 0x43, 0xa4, 0x11, 0x76, 0x40, 0x0e, 0x91, 0x74, 0xd2, 0xf2, 0x3e, 0xbd, 0x5f, 0x1e, 0xa0, 0x1e, 0xf5, 0xb4, 0xc2, 0x06, 0x60, 0x40, 0x65, 0x92, 0x42, 0x55, 0x6e, 0x02, 0x6a, 0xf2, 0xff, 0x78, 0xff, 0xab, 0x2e, 0xcb, 0x27, 0x3c, 0xae, 0x3d, 0xf8, 0x86, 0xfd, 0xba, 0xf3, 0x4e, 0x34, 0xc5, 0xec, 0xac, 0x79, 0xfb, 0xa0, 0x35, 0x23, 0x83, 0x1b, 0x33, 0x06, 0x14, 0xa9, 0x19, 0xc4, 0xc2, 0x23, 0xb5, 0x21, 0x05, 0x69, 0x0c, 0x2c, 0x0b, 0x75, 0x6e, 0x0f, 0x50, 0x6f, 0x13, 0xda, 0xb9, 0xbb, 0xc8, 0x01, 0x98, 0x69, 0xca, 0x48, 0x7a, 0x01, 0xc3, 0xee, 0x2a, 0xc5, 0x1d, 0xa0, 0xaf, 0xea, 0xfd, 0xfd, 0x76, 0xf9, 0x45, 0x4f, 0xbd, 0x21, 0x55, 0x4b, 0xba, 0x64, 0xd1, 0x62, 0x0f, 0x37, 0xe5, 0x7d, 0x56, 0x35, 0xd7, 0x87, 0x22, 0x66, 0xe9, 0xd7, 0xf4, 0xc7, 0x27, 0xba, 0x35, 0xf1, 0xd4, 0xe2, 0xeb, 0xf5, 0x4c, 0xd1, 0x0a, 0x42, 0x69, 0x56, 0x8f, 0xf7, 0x61, 0x33, 0x36, 0x9a, 0xc3, 0x90, 0x9a, 0xaa, 0xa3, 0x86, 0x14, 0x9f, 0x74, 0xde, 0xdc, 0x61, 0x28, 0x0a, 0xba, 0x1b, 0x4e, 0x8d, 0x98, 0x45, 0xf6, 0x88, 0xc9, 0x9c, 0x8d, 0x83, 0x2d, 0xfd, 0x53, 0x98, 0xfb, 0xcf, 0x03, 0x43, 0xc2, 0x42, 0x76, 0x88, 0xd4, 0xdb, 0x64, 0x56, 0x65, 0x1e, 0x2d, 0x8a, 0xd9, 0x6f, 0xce, 0xdd, 0x35, 0xce, 0x14, 0x11, 0x1b, 0x38, 0xfe, 0xa3, 0xa5, 0x56, 0x92, 0xa8, 0x18, 0xb7, 0x0b, 0x0a, 0xad };
unsigned const int cert_der_len = 942;
unsigned const char pubkey_der[] = { 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xdb, 0x82, 0x15, 0x81, 0x99, 0x84, 0x00, 0xba, 0x20, 0x2b, 0x37, 0x06, 0x49, 0xc9, 0xec, 0x50, 0x27, 0x4a, 0xb0, 0x8d, 0xd7, 0x82, 0x38, 0xb0, 0x3b, 0x50, 0x99, 0x93, 0x5d, 0xe4, 0x86, 0x58, 0x56, 0xed, 0x19, 0xf3, 0x55, 0x7a, 0x87, 0x3a, 0x75, 0x62, 0x3f, 0x4b, 0x30, 0xcd, 0xd8, 0xee, 0x0f, 0x25, 0xf2, 0x60, 0x38, 0x13, 0x64, 0x10, 0x80, 0x85, 0x40, 0xc4, 0xe6, 0xd8, 0xa7, 0x8c, 0x07, 0x0e, 0x8c, 0x63, 0xe4, 0x6a, 0x6e, 0xf3, 0xfe, 0x76, 0x8b, 0x00, 0xdf, 0xbb, 0x55, 0x18, 0x46, 0x5f, 0x17, 0x21, 0xd1, 0xd1, 0xa6, 0x8f, 0x1f, 0xe6, 0x99, 0xd4, 0xc1, 0x5a, 0x77, 0x8a, 0xb5, 0x32, 0x7e, 0xf0, 0x99, 0x91, 0x07, 0x0f, 0x3c, 0x4e, 0x70, 0xe3, 0x19, 0xb1, 0xb3, 0xae, 0x4e, 0xc8, 0x38, 0x8c, 0xd2, 0x22, 0xd0, 0x3d, 0x1f, 0x07, 0x79, 0xf8, 0x52, 0x05, 0x15, 0x13, 0x66, 0x19, 0x92, 0x55, 0x64, 0x4b, 0x8f, 0xb5, 0x08, 0xaa, 0x00, 0xf0, 0xcd, 0x8c, 0x68, 0x72, 0x4e, 0xff, 0xdd, 0xe1, 0xf6, 0x25, 0xec, 0x31, 0x80, 0xdb, 0xff, 0x62, 0xc0, 0xb1, 0x22, 0x15, 0xab, 0x52, 0x1c, 0x40, 0x2a, 0x37, 0x11, 0x75, 0x05, 0x73, 0x33, 0x39, 0x9e, 0x94, 0xe2, 0x43, 0xd0, 0xbf, 0xd1, 0x9d, 0x4d, 0xd2, 0x30, 0x7c, 0x52, 0x85, 0x21, 0xa7, 0x29, 0x7d, 0xaf, 0xb9, 0x34, 0x4e, 0x9a, 0x27, 0x1e, 0x52, 0x3b, 0x0c, 0x2d, 0x66, 0x69, 0x4f, 0xde, 0x5e, 0x0e, 0x82, 0xff, 0x90, 0x2f, 0x5d, 0x28, 0x70, 0x19, 0x99, 0x07, 0xaf, 0xf6, 0x83, 0x3a, 0xfa, 0xf2, 0x7b, 0x7e, 0x2d, 0x92, 0x7a, 0xa3, 0xa0, 0xdc, 0x17, 0xab, 0x60, 0x74, 0x6b, 0x69, 0x99, 0x10, 0x21, 0xad, 0x22, 0xf7, 0xda, 0x95, 0x8d, 0x43, 0xb7, 0xb4, 0x47, 0x1e, 0xc4, 0xb2, 0x4d, 0xee, 0x4d, 0x02, 0x03, 0x01, 0x00, 0x01 };
unsigned const int pubkey_der_len = 294;
#else //less info key
unsigned char cert_der[] = { 0x30, 0x82, 0x03, 0x02, 0x30, 0x82, 0x01, 0xea, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x08, 0x05, 0x07, 0x24, 0xbc, 0xc9, 0x27, 0xde, 0xb0, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x46, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0e, 0x57, 0x68, 0x65, 0x72, 0x65, 0x20, 0x4c, 0x61, 0x62, 0x73, 0x20, 0x4c, 0x4c, 0x43, 0x31, 0x1e, 0x30, 0x1c, 0x06, 0x03, 0x55, 0x04, 0x03, 0x0c, 0x15, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x62, 0x75, 0x73, 0x70, 0x69, 0x72, 0x61, 0x74, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x30, 0x20, 0x17, 0x0d, 0x32, 0x35, 0x30, 0x32, 0x31, 0x33, 0x31, 0x33, 0x34, 0x31, 0x35, 0x36, 0x5a, 0x18, 0x0f, 0x32, 0x31, 0x32, 0x35, 0x30, 0x31, 0x32, 0x30, 0x31, 0x33, 0x34, 0x31, 0x35, 0x36, 0x5a, 0x30, 0x3a, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x43, 0x4e, 0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x0c, 0x0a, 0x42, 0x75, 0x73, 0x20, 0x50, 0x69, 0x72, 0x61, 0x74, 0x65, 0x31, 0x0a, 0x30, 0x08, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x01, 0x36, 0x31, 0x0a, 0x30, 0x08, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x01, 0x32, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xc5, 0x04, 0xf7, 0x90, 0xd9, 0x14, 0x31, 0x8f, 0x17, 0x2e, 0xe8, 0xfa, 0xfc, 0x8e, 0xdd, 0x1f, 0x54, 0x48, 0xf7, 0xd9, 0xdf, 0xc2, 0x63, 0x2e, 0x9b, 0x91, 0xd9, 0x2a, 0x02, 0xbe, 0xde, 0x70, 0x74, 0xd7, 0x68, 0xfe, 0xf8, 0x44, 0x81, 0x0b, 0x62, 0x1e, 0x47, 0xe3, 0x7f, 0x19, 0x15, 0x91, 0x55, 0x70, 0x16, 0x7b, 0x50, 0xab, 0xc4, 0x24, 0xe4, 0x89, 0x43, 0x92, 0x05, 0x82, 0x05, 0x6b, 0x60, 0x71, 0xcd, 0x06, 0x3a, 0x9e, 0xdb, 0xe1, 0x3e, 0xb9, 0xa4, 0x27, 0x19, 0x10, 0x72, 0x7c, 0x00, 0xcb, 0x3b, 0x9d, 0xe2, 0xce, 0x93, 0xcf, 0xee, 0xcd, 0x8e, 0xd4, 0x18, 0xbf, 0xed, 0x38, 0x1e, 0x61, 0x8e, 0x04, 0x6b, 0x69, 0x34, 0x2a, 0xfb, 0xc5, 0x7e, 0xdb, 0x70, 0x6f, 0x16, 0x3a, 0x31, 0x1c, 0xbd, 0x2f, 0x1c, 0xae, 0x1e, 0xa8, 0x94, 0x0e, 0xe8, 0x0b, 0xee, 0x7d, 0x3d, 0x42, 0x9e, 0xce, 0xa5, 0x4a, 0xe8, 0x01, 0x02, 0xf4, 0x70, 0x87, 0x5c, 0xb7, 0x29, 0x91, 0x87, 0x95, 0x31, 0xa1, 0xa3, 0xb3, 0x17, 0xd7, 0x27, 0x6a, 0x55, 0x1f, 0xc2, 0x5e, 0xc1, 0xd0, 0x20, 0x59, 0x16, 0xaf, 0xec, 0x0d, 0xaa, 0x54, 0x5c, 0xf0, 0x2f, 0xce, 0xa7, 0x3e, 0x86, 0xb0, 0x23, 0x22, 0x7e, 0x2e, 0x27, 0xd6, 0x32, 0x40, 0x00, 0x5b, 0xa4, 0x87, 0xca, 0x76, 0xfb, 0xc7, 0xe9, 0x06, 0x39, 0x36, 0x63, 0x35, 0x05, 0x54, 0x33, 0x12, 0xcf, 0xfc, 0x12, 0x52, 0x37, 0x42, 0xbc, 0x22, 0x44, 0xbb, 0x32, 0x47, 0x02, 0xcd, 0x54, 0x76, 0xb9, 0xc5, 0x3b, 0x00, 0xe7, 0x21, 0x7a, 0x7e, 0x5a, 0x0c, 0x3f, 0xf1, 0x2f, 0x43, 0xd7, 0x4a, 0x9c, 0x7e, 0xbf, 0xd8, 0x2e, 0xf0, 0x52, 0xce, 0xbe, 0x77, 0xaa, 0x57, 0x6e, 0x7d, 0x0c, 0xdc, 0xec, 0xe5, 0xa0, 0x30, 0x44, 0x3a, 0x23, 0xbd, 0x02, 0x03, 0x01, 0x00, 0x01, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x25, 0xb6, 0xc0, 0x44, 0x4e, 0xdc, 0x44, 0x17, 0xfa, 0x32, 0x9c, 0xb3, 0xe8, 0x9d, 0x7b, 0x5d, 0xfb, 0xf0, 0x41, 0x07, 0x61, 0x9d, 0xac, 0xa3, 0x35, 0xbe, 0xe6, 0x75, 0x0c, 0x01, 0x33, 0x2a, 0xe7, 0xeb, 0x78, 0x2a, 0x41, 0x99, 0x06, 0x24, 0xa2, 0x70, 0xbe, 0x43, 0xf0, 0x2b, 0xa2, 0x0c, 0x26, 0x95, 0x0a, 0xfe, 0x12, 0x7c, 0x8a, 0x30, 0x6b, 0x45, 0xe8, 0x54, 0x40, 0xea, 0x99, 0x72, 0x8f, 0x05, 0x3f, 0x97, 0xcd, 0xe9, 0x90, 0xa5, 0xab, 0xd4, 0xb8, 0x72, 0xee, 0x7c, 0xd5, 0x51, 0x93, 0xc6, 0x45, 0x0e, 0x74, 0xec, 0x89, 0x3b, 0xdb, 0x64, 0x54, 0xb4, 0xb4, 0xca, 0xbb, 0x16, 0xa2, 0x61, 0x08, 0xb9, 0xca, 0xcd, 0x07, 0x0f, 0x45, 0x7a, 0xa4, 0xff, 0xab, 0xc8, 0x58, 0x3b, 0x24, 0x3a, 0x45, 0x06, 0x34, 0x65, 0xb9, 0x72, 0x30, 0x5a, 0x97, 0x35, 0x03, 0xfa, 0xb3, 0xa0, 0x81, 0x3e, 0xef, 0xc4, 0xc0, 0xbd, 0x99, 0xef, 0xf2, 0x66, 0x25, 0x8b, 0x05, 0x33, 0xbc, 0x77, 0xb0, 0x5a, 0xe3, 0xc0, 0x0d, 0xf8, 0x40, 0xf2, 0xfa, 0xdc, 0xa8, 0x6a, 0x1c, 0x33, 0x61, 0x8c, 0x53, 0x36, 0x52, 0x85, 0x18, 0x8b, 0xbb, 0x74, 0xc2, 0x42, 0x01, 0xbf, 0x92, 0x7b, 0x48, 0x9b, 0x48, 0x6a, 0xee, 0xe8, 0xf8, 0x18, 0xe0, 0x96, 0x4c, 0x78, 0x21, 0xee, 0xd9, 0x75, 0xfd, 0x5b, 0x9f, 0xc7, 0xe1, 0xb4, 0x6d, 0xa3, 0x03, 0xf7, 0x9d, 0x0a, 0xf3, 0x30, 0x43, 0x0f, 0x19, 0x65, 0x5e, 0x59, 0x5c, 0xd8, 0x60, 0x46, 0x13, 0x80, 0x4e, 0x12, 0xf6, 0x41, 0x33, 0x29, 0xb1, 0x1a, 0x6e, 0xa3, 0xef, 0xd1, 0xa9, 0xaf, 0x33, 0xaf, 0xa0, 0xc9, 0xe5, 0xb3, 0x03, 0x9f, 0x7b, 0x2b, 0x8d, 0x06, 0x2b, 0x9e, 0xca, 0x7f, 0xc9, 0xb7, 0x47, 0xee, 0x27, 0xe6, 0xfd, 0x41, 0x56, 0x77 };
unsigned int cert_der_len = 774;
unsigned char pubkey_der[] = { 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xbc, 0xaa, 0xdd, 0x26, 0xe8, 0x18, 0xdf, 0x69, 0x4c, 0xab, 0xa2, 0xe3, 0x98, 0xfc, 0x43, 0x64, 0x4c, 0x5c, 0xf5, 0xc7, 0x3c, 0x9a, 0xf7, 0x86, 0x60, 0xbc, 0x63, 0xb8, 0xf7, 0x96, 0x0a, 0x23, 0x78, 0xc6, 0x08, 0xca, 0x5a, 0xd1, 0x64, 0x80, 0xa4, 0x93, 0xd2, 0x5c, 0x91, 0x24, 0xef, 0x0d, 0x48, 0x7f, 0x69, 0x80, 0x77, 0xce, 0x17, 0xf5, 0x3e, 0xcb, 0xb0, 0xf3, 0xdf, 0x1e, 0x47, 0x9d, 0x42, 0xe3, 0x4d, 0x94, 0xff, 0xc4, 0x47, 0x5c, 0x92, 0xa8, 0xa1, 0xe5, 0x4d, 0xf9, 0x4a, 0x5e, 0xb1, 0xda, 0x8e, 0x01, 0x4f, 0xb0, 0xe4, 0xc3, 0x8f, 0x35, 0x07, 0x0d, 0xf7, 0xab, 0xf8, 0xd2, 0x51, 0xa8, 0x7b, 0x20, 0xaa, 0x43, 0xec, 0xc4, 0xe6, 0x31, 0x51, 0x4b, 0x2c, 0xb4, 0x3e, 0x09, 0x85, 0x3e, 0x58, 0x4c, 0x70, 0x30, 0x4b, 0x7b, 0x8d, 0x3a, 0x29, 0x7b, 0x49, 0x62, 0xba, 0xda, 0x11, 0x08, 0xdf, 0xc4, 0x08, 0x1a, 0xe4, 0x9b, 0x3b, 0x2d, 0x9f, 0xab, 0x5d, 0x06, 0x9c, 0x51, 0x92, 0x93, 0x6b, 0xe6, 0x03, 0x67, 0x73, 0xe2, 0x2d, 0x0a, 0x32, 0x16, 0x8c, 0x8b, 0xb5, 0x96, 0xe1, 0x9d, 0xdd, 0xf8, 0xbd, 0xff, 0xdc, 0x90, 0x48, 0xae, 0xef, 0x99, 0x99, 0x8e, 0xdb, 0xe6, 0x11, 0x09, 0xc3, 0x8c, 0xec, 0x56, 0x1e, 0xee, 0x45, 0x05, 0xb5, 0xd9, 0x43, 0xda, 0x40, 0x36, 0xcf, 0x3f, 0x00, 0x15, 0x56, 0x39, 0x56, 0x79, 0x17, 0xf8, 0x51, 0x96, 0x3f, 0x62, 0xb5, 0xcd, 0x0d, 0xa8, 0x4e, 0x62, 0xd8, 0xa6, 0x59, 0xa4, 0x26, 0xba, 0x6a, 0x76, 0xd1, 0x4e, 0xaf, 0xe1, 0xce, 0x54, 0x06, 0x0e, 0xba, 0x8f, 0x70, 0x06, 0xc9, 0xe8, 0xcc, 0xbc, 0x7a, 0x56, 0x24, 0xdc, 0x8e, 0xc6, 0x84, 0xe4, 0xaf, 0xe7, 0x65, 0xcb, 0xd1, 0x76, 0x07, 0xc7, 0xff, 0x69, 0xc2, 0x6f, 0x02, 0x03, 0x01, 0x00, 0x01 };
unsigned int pubkey_der_len = 294;
#endif
// This array of strings is used to display help USAGE examples for the dummy command
static const char* const usage[] = { "cert [-s (save to file)] [-d display] ",
                                     "Validate Bus Pirate SHA256 cert: cert",
                                     "Display cert and public key: cert -d",
                                     "Save cert and public key to file: cert -s" };

static const struct ui_help_options options[] = {
/*    { 1, "", T_HELP_DUMMY_COMMANDS },    // section heading
    { 0, "init", T_HELP_DUMMY_INIT },    // init is an example we'll find by position
    { 0, "test", T_HELP_DUMMY_TEST },    // test is an example we'll find by position
    { 1, "", T_HELP_DUMMY_FLAGS },       // section heading for flags
    { 0, "-b", T_HELP_DUMMY_B_FLAG },    //-a flag, with no optional string or integer
    { 0, "-i", T_HELP_DUMMY_I_FLAG },    //-b flag, with optional integer
    { 0, "-f", T_HELP_DUMMY_FILE_FLAG }, //-f flag, a file name string*/
    {0, "-h", T_HELP_FLAG}
};

void print_x509_info(const mbedtls_x509_crt *cert, char *buf, int buflen) {
    // Print the subject name
    mbedtls_x509_dn_gets(buf, buflen, &cert->subject);
    printf("Subject: %s\r\n", buf);

    // Print the issuer name
    mbedtls_x509_dn_gets(buf, buflen, &cert->issuer);
    printf("Issuer: %s\r\n", buf);

    // Print the validity period
    const mbedtls_x509_time *valid_from = &cert->valid_from;
    const mbedtls_x509_time *valid_to = &cert->valid_to;
    printf("Valid from: %04d-%02d-%02d %02d:%02d:%02d\r\n",
           valid_from->year, valid_from->mon, valid_from->day,
           valid_from->hour, valid_from->min, valid_from->sec);
    printf("Valid to: %04d-%02d-%02d %02d:%02d:%02d\r\n",
           valid_to->year, valid_to->mon, valid_to->day,
           valid_to->hour, valid_to->min, valid_to->sec);

    // Print the serial number
    mbedtls_x509_serial_gets(buf, buflen, &cert->serial);
    printf("Serial Number: %s\r\n", buf);

    // Print the public key
    //mbedtls_pk_write_pubkey_pem(&cert->pk, (unsigned char *)buf, sizeof(buf));
    //printf("Public Key: %s\n", buf);

    // Iterate through extensions to find custom OIDs
    /*
    const mbedtls_x509_sequence *ext = &cert->v3_ext;
    mbedtls_x509_get_ext(ext);
    while (ext != NULL && ext->buf.len != 0) {
        mbedtls_asn1_buf oid = ext->buf;



        // Convert OID to string
        char oid_str[128];
        mbedtls_oid_get_numeric_string(oid_str, sizeof(oid_str), &oid);

          printf("Extension OID: %s", oid_str);

        // Check for custom OIDs
        if (strcmp(oid_str, "1.3.6.1.4.1.11129.2.1.1") == 0 ||
            strcmp(oid_str, "1.3.6.1.4.1.11129.2.1.2") == 0 ||
            strcmp(oid_str, "1.3.6.1.4.1.11129.2.1.3") == 0) {
            printf("Extension OID: %s\n", oid_str);
            //printf("Critical: %s\n", ext->critical ? "True" : "False");
            printf("Value: ");
            for (size_t i = 0; i < ext->buf.len; i++) {
                printf("%02X", ext->buf.p[i]);
            }
            printf("\n");
        }

        ext = ext->next;
    }    */
}

void cert_handler(struct command_result* res) {
    if (ui_help_show(res->help_flag, usage, count_of(usage), &options[0], count_of(options))) {
        return;
    }

    mbedtls_x509_crt cert;
    mbedtls_pk_context public_key;
    unsigned char buf[2000];
    unsigned char hash[32];

    // if display or save to file
    bool s_flag = cmdln_args_find_flag('s');
    bool d_flag = cmdln_args_find_flag('d');

    mbedtls_x509_crt_init(&cert);
    mbedtls_pk_init(&public_key);

    printf("Parsing certificate\r\n");
    int ret = mbedtls_x509_crt_parse(&cert, cert_der, cert_der_len);
    if (ret != 0) {
        char error_buf[100];
        mbedtls_strerror(ret, error_buf, 100);
        printf("Failed to parse certificate: %s\r\n", error_buf);
        return;
    }

    printf("Parsing public key\r\n");
    ret = mbedtls_pk_parse_public_key(&public_key, pubkey_der, pubkey_der_len);
    if (ret != 0) {
        char error_buf[100];
        mbedtls_strerror(ret, error_buf, 100);
        printf("Failed to parse public key: %s\r\n", error_buf);
        return;
    }

    printf("Certificate contents:\r\n");
    print_x509_info(&cert, (char *)buf, sizeof(buf)); 

    // Compute the SHA-256 hash of the TBS (to-be-signed) part of the certificate
    printf("\r\nVerifying the SHA-256 signature\r\n");
    const mbedtls_md_info_t *mdinfo = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
    ret = mbedtls_md(
        //mbedtls_md_info_from_type(MBEDTLS_MD_SHA256),
        mdinfo,
        cert.tbs.p, cert.tbs.len, hash);
    if (ret != 0) {
        char error_buf[100];
        mbedtls_strerror(ret, error_buf, 100);
        printf("Failed to create hash: %s\r\n", error_buf);
        goto cert_cleanup;
    }

    printf("Certificate signature   length: %d\r\n", cert.sig.len);
    printf("SHA-256 hash length: %d\r\n", mdinfo->size);
    printf("SHA-256 hash: ");
    for(int i = 0; i < mdinfo->size; i++) {
        printf("%02X", hash[i]);
    }
    printf("\r\n\r\n");

    // Verify the certificate signature using the public key
    ret = mbedtls_pk_verify(
        &public_key,
        MBEDTLS_MD_SHA256,
        hash, 0,
        cert.sig.p, cert.sig.len
    );
    if (ret != 0) {
        char error_buf[100];
        mbedtls_strerror(ret, error_buf, 100);
        printf("Failed to verify: %s\r\n", error_buf);
        if(!d_flag && !s_flag) goto cert_cleanup;
        else goto cert_dump;
    }

    printf("Certificate verified successfully\r\n\r\n");

    pico_unique_board_id_t id;
    pico_get_unique_board_id(&id);

    printf("RP2xxx Unique Serial Number: ");
    for (int i = 0; i < PICO_UNIQUE_BOARD_ID_SIZE_BYTES; i++) {
        printf("%02X%s", id.id[i], (i < PICO_UNIQUE_BOARD_ID_SIZE_BYTES-1) ? ":" : "");
    }
    printf("\r\n");
    //uint nr = (cert.serial.len <= 32)
    //? cert.serial.len  : 28;
    printf("Certificate Serial Number: ");
    char serial[8];
    uint8_t serial_len = 0;
    for (uint i = 0; i < cert.serial.len; i++) {
        if (i == 0 && PICO_UNIQUE_BOARD_ID_SIZE_BYTES > 1 && cert.serial.p[i] == 0x0) {
            continue;
        }
        if(serial_len < PICO_UNIQUE_BOARD_ID_SIZE_BYTES) {
            serial[serial_len] = cert.serial.p[i];
            serial_len++;
        }
        printf("%02X%s", cert.serial.p[i], (i < cert.serial.len - 1) ? ":" : "");
    }
    printf("\r\n");
    //verify that the serial number in the certificate matches the RP2040 unique serial number
    if (memcmp(serial, id.id, PICO_UNIQUE_BOARD_ID_SIZE_BYTES) == 0) {
        printf("Certificate Serial Number matches RP2xxx Unique Serial Number\r\n");
    } else {
        printf("Certificate Serial Number does not match RP2xxx Unique Serial Number\r\n");
    }

    if (!s_flag && !d_flag) goto cert_cleanup; //done
cert_dump:
    printf("\r\n");
    // Buffer to hold the PEM-encoded certificate
    size_t pem_len;
    // Convert DER to PEM
    ret = mbedtls_pem_write_buffer("-----BEGIN CERTIFICATE-----\n",
                                   "-----END CERTIFICATE-----\n",
                                   cert_der, cert_der_len,
                                   buf, sizeof(buf), &pem_len);
    if (ret != 0) {
        char error_buf[100];
        mbedtls_strerror(ret, error_buf, 100);
        printf("Failed to write certificate PEM: %s\r\n", error_buf);
        goto cert_cleanup;
    }

    if(d_flag){
        printf("Certificate PEM:\r\n");
        // Print the PEM-encoded certificate
        for(uint i = 0; i < pem_len; i++) {
            if(buf[i] == '\n') {
                printf("\r\n");
                continue;
            }
            printf("%c", buf[i]);
        }
        printf("\r\n");  
    }

    if(s_flag){

        // create a file
        printf("Creating file cert.pem\r\n");
        FIL file_handle;                           
        FRESULT result;    
        const char cert_file[]="cert.pem";
        result = f_open(&file_handle, cert_file, FA_CREATE_ALWAYS | FA_WRITE); // create the file, overwrite if it exists
        if (result != FR_OK) {                                            // error
            printf("Error creating file %s\r\n", cert_file);
            system_config.error = true; // set the error flag
            goto cert_cleanup;
        }

        UINT bytes_written; // somewhere to store the number of bytes written
        result = f_write(&file_handle, buf, pem_len, &bytes_written); // write the data to the file
        if (result != FR_OK) {
            printf("Error writing to file %s\r\n", cert_file);
            FRESULT result2 = f_close(&file_handle); // close the file
            if (result2 != FR_OK) {
                
            }
            system_config.error = true; // set the error flag
            goto cert_cleanup;
        }

        // close the file
        result = f_close(&file_handle); // close the file
        if (result != FR_OK) {
            printf("Error closing file %s\r\n", cert_file);
            system_config.error = true; // set the error flag
            goto cert_cleanup;
        }
    }

    // Convert DER to PEM and display the public key
    ret = mbedtls_pem_write_buffer("--------BEGIN PUBLIC KEY--------\n",
                                   "--------END PUBLIC KEY--------\n",
                                    pubkey_der, pubkey_der_len,
                                    buf, sizeof(buf), &pem_len);
    if (ret != 0) {
        char error_buf[100];
        mbedtls_strerror(ret, error_buf, 100);
        printf("Failed to write public key PEM: %s\r\n", error_buf);
        goto cert_cleanup;
    }
  
    if(d_flag){
        printf("Public key PEM:\r\n");
        // Print the PEM-encoded certificate
        for(uint i = 0; i < pem_len; i++) {
            if(buf[i] == '\n') {
                printf("\r\n");
                continue;
            }
            printf("%c", buf[i]);
        }
        printf("\r\n");  
    }

    if(s_flag){
        // create a file
        printf("Creating file pubkey.pem\r\n");
        FIL file_handle;                           
        FRESULT result;    
        const char key_file[]="pubkey.pem";
        result = f_open(&file_handle, key_file, FA_CREATE_ALWAYS | FA_WRITE); // create the file, overwrite if it exists
        if (result != FR_OK) {                                            // error
            printf("Error creating file %s\r\n", key_file);
            system_config.error = true; // set the error flag
            goto cert_cleanup;
        }

        UINT bytes_written; // somewhere to store the number of bytes written
        result = f_write(&file_handle, buf, pem_len, &bytes_written); // write the data to the file
        if (result != FR_OK) {
            printf("Error writing to file %s\r\n", key_file);
            FRESULT result2 = f_close(&file_handle); // close the file
            if (result2 != FR_OK) {
                
            }
            system_config.error = true; // set the error flag
            goto cert_cleanup;
        }

        // close the file
        result = f_close(&file_handle); // close the file
        if (result != FR_OK) {
            printf("Error closing file %s\r\n", key_file);
            system_config.error = true; // set the error flag
            goto cert_cleanup;
        }
    }

cert_cleanup:
    mbedtls_x509_crt_free(&cert);
    mbedtls_pk_free(&public_key);    

}