/*
 * This file is part of the Bus Pirate project (http://code.google.com/p/the-bus-pirate/).
 *
 * Written and maintained by the Bus Pirate project.
 *
 * To the extent possible under law, the project has
 * waived all copyright and related or neighboring rights to Bus Pirate. This
 * work is published from United States.
 *
 * For details see: http://creativecommons.org/publicdomain/zero/1.0/.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

/* Binary access modes for Bus Pirate scripting */

// #include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "pirate.h"
#include "queue.h"
#include "usb_rx.h"
#include "usb_tx.h"
#include "pirate.h"
// #include "sump.h"
#include "command_struct.h" //needed for same reason as bytecode and needs same fix
#include "bytecode.h"
#include "modes.h"
#include "binio_helpers.h"
#include "tusb.h"
#include "system_config.h"
#include "pirate/amux.h"
#include "commands/global/w_psu.h"
#include "pirate/bio.h"
#include "commands/global/p_pullups.h"
#include "pirate/psu.h"
#include "commands/global/cmd_mcu.h"
#include "pirate/hwi2c_pio.h"
#include "mode/hwi2c.h"
#include "mode/hwspi.h"
#include "pirate/hwspi.h"
#include "bpio_builder.h" // Generated by `flatcc`.
#include "bpio_reader.h"  
#include "bpio_verifier.h"
#include "lib/nanocobs/cobs.h"

const char dirtyproto_mode_name[] = "BPIO2 flatbuffer interface";
uint32_t time_start, time_end;

#define CDC_INTF 1

// A helper to simplify creating vectors from C-arrays.
#define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))

// This allows us to verify result in optimized builds.
#define test_assert(x) do { if (!(x)) { assert(0); return -1; }} while(0)

bool bpio_debug = false;

void error_response(const char *error_msg, flatcc_builder_t *B);

bool mode_change_new(const char *mode_name, bpio_mode_configuration_t *mode_config) {
    // compare mode name to modes.protocol_name
    for (uint8_t i = 0; i < count_of(modes); i++) {
        if (strcasecmp(mode_name, modes[i].protocol_name) == 0) {
            if(modes[i].bpio_handler==NULL) {
                if(bpio_debug) printf("[Mode Change] Protocol %s does not support BPIO handler\r\n", mode_name);
                return true;
            }
            modes[system_config.mode].protocol_cleanup();
            system_config.mode = i;
            if(modes[system_config.mode].bpio_configure==NULL) {
                if(bpio_debug) printf("[Mode Change] Protocol %s does not support BPIO configuration\r\n", mode_name);
            }else{
                modes[system_config.mode].bpio_configure(mode_config);
            }
            modes[system_config.mode].protocol_setup_exc();
            return false;
        }
    }
    return true;
}

#define COBS_TFSV COBS_TINYFRAME_SENTINEL_VALUE

typedef unsigned char cobs_byte_t;



cobs_ret_t t_cobs_encode_inc_begin(void *out_enc, size_t enc_max, cobs_enc_ctx_t *out_ctx) {
  if (!out_enc || !out_ctx) {
    return COBS_RET_ERR_BAD_ARG;
  }
  if (enc_max < 2) {
    return COBS_RET_ERR_BAD_ARG;
  }

  out_ctx->dst = out_enc;
  out_ctx->dst_max = enc_max;
  out_ctx->cur = 1;
  out_ctx->code = 1;
  out_ctx->code_idx = 0;
  out_ctx->need_advance = 0;
  return COBS_RET_SUCCESS;
}

cobs_ret_t t_cobs_encode_inc(cobs_enc_ctx_t *ctx, void const *dec, size_t dec_len) {
  if (!ctx || !dec) {
    return COBS_RET_ERR_BAD_ARG;
  }
  size_t dst_idx = ctx->cur;
  size_t const enc_max = ctx->dst_max;
  if ((enc_max - dst_idx) < dec_len) {
    return COBS_RET_ERR_EXHAUSTED;
  }
  if (!dec_len) {
    return COBS_RET_SUCCESS;
  }

  size_t dst_code_idx = ctx->code_idx;
  unsigned code = ctx->code;
  int need_advance = ctx->need_advance;

  cobs_byte_t const *const src = (cobs_byte_t const *)dec;
  cobs_byte_t *const dst = (cobs_byte_t *)ctx->dst;
  size_t src_idx = 0;

  if (need_advance) {
    if (++dst_idx >= enc_max) {
      return COBS_RET_ERR_EXHAUSTED;
    }
    need_advance = 0;
  }

  while (dec_len--) {
    cobs_byte_t const byte = src[src_idx];
    if (byte) {
      dst[dst_idx] = byte;
      if (++dst_idx >= enc_max) {
        return COBS_RET_ERR_EXHAUSTED;
      }
      ++code;
    }

    if ((byte == 0) || (code == 0xFF)) {
      dst[dst_code_idx] = (cobs_byte_t)code;
      dst_code_idx = dst_idx;
      code = 1;

      if ((byte == 0) || dec_len) {
        if (++dst_idx >= enc_max) {
          return COBS_RET_ERR_EXHAUSTED;
        }
      } else {
        need_advance = !dec_len;
      }
    }
    ++src_idx;
  }

  ctx->cur = dst_idx;
  ctx->code = code;
  ctx->code_idx = dst_code_idx;
  ctx->need_advance = need_advance;
  return COBS_RET_SUCCESS;
}

cobs_ret_t t_cobs_encode_inc_end(cobs_enc_ctx_t *ctx, size_t *out_enc_len) {
  if (!ctx || !out_enc_len) {
    return COBS_RET_ERR_BAD_ARG;
  }

  cobs_byte_t *const dst = (cobs_byte_t *)ctx->dst;
  size_t cur = ctx->cur;
  dst[ctx->code_idx] = (cobs_byte_t)ctx->code;
  dst[cur++] = COBS_FRAME_DELIMITER;
  *out_enc_len = cur;
  return COBS_RET_SUCCESS;
}

cobs_ret_t t_cobs_encode(void const *dec,
                       size_t dec_len,
                       void *out_enc,
                       size_t enc_max,
                       size_t *out_enc_len) {
  if (!out_enc_len) {
    return COBS_RET_ERR_BAD_ARG;
  }

  cobs_enc_ctx_t ctx;
  cobs_ret_t r;
  time_start = time_us_32();
  if ((r = t_cobs_encode_inc_begin(out_enc, enc_max, &ctx)) != COBS_RET_SUCCESS) {
    return r;
  }
  if(bpio_debug) printf("[COBS] %dus", time_us_32() - time_start);
  time_start = time_us_32();
  if ((r = t_cobs_encode_inc(&ctx, dec, dec_len)) != COBS_RET_SUCCESS) {
    return r;
  }
  if(bpio_debug) printf(" %dus", time_us_32() - time_start);
  time_start = time_us_32();
  r = t_cobs_encode_inc_end(&ctx, out_enc_len);
  if(bpio_debug) printf(" %dus\r\n", time_us_32() - time_start);
  return r;
}

static inline void send_packet(flatcc_builder_t *B) {
    uint8_t* buf;
    size_t len = flatcc_builder_get_buffer_size(B);
    if(bpio_debug) printf("[Send Packet] Length %d\r\n", len);
         
    buf = flatcc_builder_finalize_buffer(B, &len); //23uS
    //if(bpio_debug) printf("[Send Packet] Finalized buffer\r\n");

    uint8_t cobs_buf[700];
    // Encode the buffer using COBS
    size_t cobs_len;
    uint32_t temp_time_start = time_us_32();
    cobs_ret_t cobs_result = cobs_encode(buf, len, cobs_buf, sizeof(cobs_buf), &cobs_len);
    if(bpio_debug) printf("[COBS] Encoded in %dus\r\n", time_us_32() - temp_time_start);
    free(buf); // Free the buffer allocated by flatcc_builder_finalize_buffer
    
    if (cobs_result != COBS_RET_SUCCESS) {
        const char *error_msg = "COBS encoding failed";
        if(bpio_debug) printf("[Send Packet] Error: %s\r\n", error_msg);
        //error_response(error_msg, B);
        return;
    }
    if(bpio_debug) printf("[Send Packet] COBS encoded buffer length: %zu\r\n", cobs_len);

    uint8_t *buf_ptr = cobs_buf;
    uint32_t len32 = cobs_len;
    temp_time_start = time_us_32();
    while (len32) { //80uS
        if (tud_cdc_n_write_available(CDC_INTF) >= 64) {
            uint32_t chunk_size = (len32 > 64) ? 64 : len32;
            tud_cdc_n_write(CDC_INTF, buf_ptr, chunk_size);
            tud_cdc_n_write_flush(CDC_INTF);
            buf_ptr += chunk_size;
            len32 -= chunk_size;
        }
    }
    if(bpio_debug) printf("[Send Packet] Sent %d bytes in %dus\r\n", len, time_us_32() - temp_time_start);
}

uint32_t status_request(bpio_RequestPacket_table_t packet, flatcc_builder_t *B) {
    const char *error = NULL;
    uint32_t query_flags=0;

    bpio_StatusRequest_table_t status_request = (bpio_StatusRequest_table_t) bpio_RequestPacket_contents(packet);
    if(status_request == 0) {
        const char *status_request_error_msg = "Status request is NULL";
        if(bpio_debug) printf("[Status Request] Error: %s\r\n", status_request_error_msg);
        error = status_request_error_msg;
    }else{
        bpio_StatusRequestTypes_vec_t query = bpio_StatusRequest_query(status_request);
        if(query == 0){ //no query, send all
            query_flags|= 1u<<bpio_StatusRequestTypes_All;
        }else{
            // Iterate through the vector
            if(bpio_debug) printf("[Status Request] Query types: ");
            for (size_t i = 0; i < bpio_StatusRequestTypes_vec_len(query); i++) {
                bpio_StatusRequestTypes_enum_t query_type = bpio_StatusRequestTypes_vec_at(query, i);
                if(bpio_debug) printf("%zu ", query_type);
                // Set the corresponding bit in query_flags
                query_flags |= (1u << query_type);
            }
            if(bpio_debug) printf("\r\n");
        }
    }

    bpio_StatusResponse_start(B);
    if(query_flags & (1u << bpio_StatusRequestTypes_Version)||query_flags & (1u << bpio_StatusRequestTypes_All)) {
        // Send version information
        if(bpio_debug) printf("[Status Request] Version requested\r\n");
        bpio_StatusResponse_hardware_version_major_add(B, BP_FIRMWARE_VERSION_MAJOR);
        bpio_StatusResponse_hardware_version_minor_add(B, BP_FIRMWARE_VERSION_REVISION);
        bpio_StatusResponse_firmware_version_major_add(B, 0);
        bpio_StatusResponse_firmware_version_minor_add(B, 0);
        flatbuffers_string_ref_t git_hash = flatbuffers_string_create_str(B, BP_FIRMWARE_HASH);
        bpio_StatusResponse_firmware_git_hash_add(B, git_hash);
        flatbuffers_string_ref_t firmware_date = flatbuffers_string_create_str(B, BP_FIRMWARE_TIMESTAMP);
        bpio_StatusResponse_firmware_date_add(B, firmware_date);

    }

    //modes_available and current mode
    if(query_flags & (1u << bpio_StatusRequestTypes_Mode) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        if(bpio_debug) printf("[Status Request] Modes available requested\r\n");
        
        flatbuffers_string_ref_t current_mode_name = flatbuffers_string_create_str(B, modes[system_config.mode].protocol_name);
        bpio_StatusResponse_mode_current_add(B, current_mode_name);

        bpio_StatusResponse_modes_available_start(B); // <-- Start the vector!
        for (uint8_t i = 0; i < count_of(modes); i++) {
            flatbuffers_string_ref_t name = flatbuffers_string_create_str(B, modes[i].protocol_name);
            bpio_StatusResponse_modes_available_push(B, name);
        }        
        bpio_StatusResponse_modes_available_end(B); // <-- End the vector!

        bpio_StatusResponse_mode_pin_labels_start(B);
        for (uint8_t i = 0; i < HW_PINS; i++) {
            flatbuffers_string_ref_t label = flatbuffers_string_create_str(B, system_config.pin_labels[i]);
            bpio_StatusResponse_mode_pin_labels_push(B, label);
        }
        bpio_StatusResponse_mode_pin_labels_end(B);

        bpio_StatusResponse_mode_bitorder_msb_add(B, system_config.bit_order == 0);
    }

    // led_count
    if(query_flags & (1u << bpio_StatusRequestTypes_LED) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        if(bpio_debug) printf("[Status Request] LED count requested\r\n");
        bpio_StatusResponse_led_count_add(B, RGB_LEN);
    }

    // Pullup status
    if(query_flags & (1u << bpio_StatusRequestTypes_Pullup) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        if(bpio_debug) printf("[Status Request] Pullup status requested\r\n");
        bpio_StatusResponse_pullup_enabled_add(B, system_config.pullup_enabled);
        #ifdef BP_HW_PULLX
        bpio_StatusResponse_pullx_config_add(B, 0x00000000u); //todo: implement pull-x config
        #endif
    }

    // PSU status
    if(query_flags & (1u << bpio_StatusRequestTypes_PSU) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        if(bpio_debug) printf("[Status Request] PSU status requested\r\n");
        bpio_StatusResponse_psu_enabled_add(B, system_config.psu);
        bpio_StatusResponse_psu_set_mv_add(B, system_config.psu_voltage/10);
        bpio_StatusResponse_psu_set_ma_add(B, system_config.psu_current_limit/10000);
        uint32_t vout, isense, vreg;
        bool fuse;
        psu_measure(&vout, &isense, &vreg, &fuse);
        bpio_StatusResponse_psu_measured_mv_add(B, vout);
        bpio_StatusResponse_psu_measured_ma_add(B, isense/1000);
        bpio_StatusResponse_psu_current_error_add(B, system_config.psu_current_error);

    }

    //ADC status, return the voltage on IO0...IO7
    if(query_flags & (1u << bpio_StatusRequestTypes_ADC) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        if(bpio_debug) printf("[Status Request] ADC status requested\r\n");
        amux_sweep();
        bpio_StatusResponse_adc_mv_start(B);
        for (uint8_t i = 1; i < 9; i++) {
            bpio_StatusResponse_adc_mv_push(B, hw_pin_voltage_ordered[i]);
        }
        bpio_StatusResponse_adc_mv_end(B);
    }

    // IO status
    if(query_flags & (1u << bpio_StatusRequestTypes_IO) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        if(bpio_debug) printf("[Status Request] IO status requested\r\n");
        // direction is 0-7
        // value is 8-15
        uint32_t pins = gpio_get_all();
        bpio_StatusResponse_io_direction_add(B, (uint8_t)(pins & 0xff)); // Get the first 8 bits for direction
        bpio_StatusResponse_io_value_add(B, (uint8_t)((pins >> 8) & 0xff)); // Get the next 8 bits for value        
    }

    // Disk status
    if(query_flags & (1u << bpio_StatusRequestTypes_Disk) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        if(bpio_debug) printf("[Status Request] Disk status requested\r\n");
        bpio_StatusResponse_disk_size_mb_add(B, system_config.storage_size * 1000);
        bpio_StatusResponse_disk_used_mb_add(B, 0.0f); //todo: implement disk free space    
    }

    if(error) {
        bpio_StatusResponse_error_add(B, flatbuffers_string_create_str(B, error));
    }

    // end status response table
    bpio_StatusResponse_ref_t status_response = bpio_StatusResponse_end(B);
    
    // add to packet wrapper
    bpio_ResponsePacket_start_as_root(B);
    bpio_ResponsePacket_contents_StatusResponse_add(B, status_response);
    bpio_ResponsePacket_end_as_root(B);            
    send_packet(B);
}


uint32_t configuration_request(bpio_RequestPacket_table_t packet, flatcc_builder_t *B) {
    const char *error = NULL;

    bpio_ConfigurationRequest_table_t config_request = (bpio_ConfigurationRequest_table_t) bpio_RequestPacket_contents(packet);
    if(config_request == 0) {
        const char *config_request_error_msg = "Configuration request is NULL";
        if(bpio_debug) printf("[Config Request] Error: %s\r\n", config_request_error_msg);
        error = config_request_error_msg;
        goto config_response_error;
    }

    // does it have mode?
    if(bpio_ConfigurationRequest_mode_is_present(config_request)) {
        // change mode
        const char* mode_str = bpio_ConfigurationRequest_mode_get(config_request);
        //get the mode configuration
        bpio_ModeConfiguration_table_t mode_config = bpio_ConfigurationRequest_mode_configuration(config_request);
        if(mode_config == 0){
            static const char *mode_config_error_msg = "Mode configuration not present";
            if(bpio_debug) printf("[Config Request] Error: %s\r\n", mode_config_error_msg);
            error = mode_config_error_msg;
            goto config_response_error;
        }
        bpio_mode_configuration_t mode_config_data;
        mode_config_data.speed = bpio_ModeConfiguration_speed_get(mode_config);
        mode_config_data.data_bits = bpio_ModeConfiguration_data_bits_get(mode_config);
        mode_config_data.parity = bpio_ModeConfiguration_parity_get(mode_config);
        mode_config_data.stop_bits = bpio_ModeConfiguration_stop_bits_get(mode_config);
        mode_config_data.flow_control = bpio_ModeConfiguration_flow_control_get(mode_config);
        mode_config_data.signal_inversion = bpio_ModeConfiguration_signal_inversion_get(mode_config);
        mode_config_data.clock_stretch = bpio_ModeConfiguration_clock_stretch_get(mode_config);
        mode_config_data.clock_polarity = bpio_ModeConfiguration_clock_polarity_get(mode_config);
        mode_config_data.clock_phase = bpio_ModeConfiguration_clock_phase_get(mode_config);
        mode_config_data.chip_select_idle = bpio_ModeConfiguration_chip_select_idle_get(mode_config);
        mode_config_data.submode = bpio_ModeConfiguration_submode_get(mode_config);
        mode_config_data.tx_modulation = bpio_ModeConfiguration_tx_modulation_get(mode_config);
        mode_config_data.rx_sensor = bpio_ModeConfiguration_rx_sensor_get(mode_config);
        mode_config_data.debug = bpio_debug;
        
        if (mode_change_new(mode_str, &mode_config_data)) {
            static const char *mode_error_msg = "Invalid mode name";
            if(bpio_debug) printf("[Config Request] Error: %s '%s'\r\n", mode_error_msg, mode_str);
            error = mode_error_msg;
            goto config_response_error;
        }
        //todo: configure mode
        if(bpio_debug) printf("[Config Request] Mode changed to '%s'\r\n", mode_str);
    }

    bool bit_order_msb = bpio_ConfigurationRequest_mode_bitorder_msb_get(config_request);
    if(bit_order_msb) {
        system_config.bit_order = 0; // MSB first
        if(bpio_debug) printf("[Config Request] Bit order set to MSB first\r\n");
    }

    bool bit_order_lsb = bpio_ConfigurationRequest_mode_bitorder_lsb_get(config_request);
    if(bit_order_lsb) {
        system_config.bit_order = 1; // LSB first
        if(bpio_debug) printf("[Config Request] Bit order set to LSB first\r\n");
    }

    bool psu_disable = bpio_ConfigurationRequest_psu_disable_get(config_request);
    if(psu_disable){
        psucmd_disable();
        if(bpio_debug) printf("[Config Request] Power supply disabled\r\n");
    }

    bool psu_enable = bpio_ConfigurationRequest_psu_enable_get(config_request);
    if(psu_enable){
        uint32_t voltage_mv = 3300;
        if(bpio_ConfigurationRequest_psu_set_mv_is_present(config_request)) {
            voltage_mv = bpio_ConfigurationRequest_psu_set_mv_get(config_request);
            //check out of range
            if(voltage_mv < 800 || voltage_mv > 5000) {
                static const char *voltage_error_msg = "PSU Voltage out of range (800-5000 mV)";
                if(bpio_debug) printf("[Config Request] Error: %s (%d mV)\r\n", voltage_error_msg, voltage_mv);
                error = voltage_error_msg;
                goto config_response_error;
            }
        }
            
        uint32_t current_ma = 300; // default
        bool current_limit_override = false;
        if(bpio_ConfigurationRequest_psu_set_ma_is_present(config_request)) {
            current_ma = bpio_ConfigurationRequest_psu_set_ma_get(config_request);
            if(current_ma==0) {
                current_limit_override = true; // 0 means no limit
                if(bpio_debug) printf("[Config Request] PSU current limit override enabled\r\n");
            }else{
                //check out of range
                if(current_ma < 1 || current_ma > 500) {
                    static const char *current_error_msg = "PSU Current out of range (1-500 mA)";
                    if(bpio_debug) printf("[Config Request] Error: %s (%d mA)\r\n", current_error_msg, current_ma);
                    error = current_error_msg;
                    goto config_response_error;
                }
            }
        }

        if(bpio_debug) printf("[Config Request] PSU Voltage: %f, Current: %f, Override: %s\r\n", (float)voltage_mv/1000.0f, (float)current_ma, current_limit_override?"true":"false");
        
        uint8_t psu_error = psucmd_enable((float)voltage_mv/1000.0f, (float)current_ma, current_limit_override);
        if (psu_error) {
            static const char *psu_error_msg = "Power supply initialization failed";
            if(bpio_debug) printf("[Config Request] Error: %s (%d)\r\n", psu_error_msg, psu_error);
            error = psu_error_msg;
            goto config_response_error;
        }

        if(bpio_debug) printf("[Config Request] Power supply enabled\r\n");
    }

    uint8_t pullup_disable = bpio_ConfigurationRequest_pullup_disable_get(config_request);
    if(pullup_disable){
        pullups_disable();
        if(bpio_debug) printf("[Config Request] Pull-up resistors disabled\r\n");
    }

    uint8_t pullup_enable = bpio_ConfigurationRequest_pullup_enable_get(config_request);
    if(pullup_enable){
        pullups_enable();
        if(bpio_debug) printf("[Config Request] Pull-up resistors enabled\r\n");
    }
    
    #ifdef BP_HW_PULLX
    //pullx_config
    #endif

    //TODO: this needs to respect any in-use pins (check system_config?)
    if(bpio_ConfigurationRequest_io_direction_mask_is_present(config_request)){
        uint8_t io_direction_mask = bpio_ConfigurationRequest_io_direction_mask_get(config_request);
        uint8_t io_direction = bpio_ConfigurationRequest_io_direction_get(config_request);
        for(uint8_t i = 0; i < 8; i++) {
            if(io_direction_mask & (1u << i)) {
                //set the direction
                if(io_direction & (1u << i)) {
                    // first set the buffer to output
                    gpio_put(i, BUFDIR_OUTPUT);
                    // now set pin to output
                    gpio_set_dir(i+8, GPIO_OUT);
                    if(bpio_debug) printf("[Config Request] IO%d set to output\r\n", i);
                }else{
                    // first set the pin to input
                    gpio_set_dir(i+8, GPIO_IN);
                    // now set buffer to input
                    gpio_put(i, BUFDIR_INPUT);
                    if(bpio_debug) printf("[Config Request] IO%d set to input\r\n", i);
                }
            }
        }
    }

    if(bpio_ConfigurationRequest_io_value_mask_is_present(config_request)) {
        uint8_t io_value_mask = bpio_ConfigurationRequest_io_value_mask_get(config_request);
        uint8_t io_value = bpio_ConfigurationRequest_io_value_get(config_request);
        for(uint8_t i = 0; i < 8; i++) {
            if(io_value_mask & (1u << i)) {
                //set the value
                gpio_put(i+8, (io_value & (1u << i)));
                if(bpio_debug) printf("[Config Request] IO%d set to %s\r\n", i, (io_value & (1u << i)) ? "high" : "low");
            }
        }    
    }

    if(bpio_ConfigurationRequest_led_resume_is_present(config_request)) {
        bool led_resume = bpio_ConfigurationRequest_led_resume_get(config_request);
        if (led_resume) {
            if(bpio_debug) printf("[Config Request] LED effect resumed\r\n");
            rgb_irq_enable(true); // Enable the RGB IRQ
        }
    }

    if(bpio_ConfigurationRequest_led_color_is_present(config_request)) {
        flatbuffers_uint32_vec_t led_color = bpio_ConfigurationRequest_led_color_get(config_request);
        if(flatbuffers_uint32_vec_len(led_color) < RGB_LEN) {
            static const char *led_error_msg = "LED color vector (array) too short";
            if(bpio_debug) printf("[Config Request] Error: %s: %d, this device has %d LEDs\r\n", led_error_msg, flatbuffers_uint32_vec_len(led_color), RGB_LEN);
            error = led_error_msg;
            goto config_response_error;
        }else{
            uint32_t colors[RGB_LEN];
            if(bpio_debug) printf("[Config Request] LED colors: ");
            for (size_t i = 0; i < RGB_LEN; i++) {
                colors[i] = flatbuffers_uint32_vec_at(led_color, i);
                if(bpio_debug) printf("0x%06X ", colors[i]);
            }
            if(bpio_debug) printf("\r\n");
            rgb_irq_enable(false);
            rgb_set_array(colors);            
        }
    }

    if(bpio_ConfigurationRequest_print_string_is_present(config_request)) {
        const char *print_str = bpio_ConfigurationRequest_print_string_get(config_request);
        if(bpio_debug) printf("[Config Request] Print string to terminal: %s\r\n", print_str);
        if(tud_cdc_n_connected(0)) printf("%s", print_str);
    }

    bool hardware_bootloader = bpio_ConfigurationRequest_hardware_bootloader_get(config_request);
    if(hardware_bootloader) {
        if(bpio_debug) printf("[Config Request] Entering bootloader mode\r\n");
        cmd_mcu_jump_to_bootloader();
    }

    bool hardware_reset = bpio_ConfigurationRequest_hardware_reset_get(config_request);
    if(hardware_reset) {
        if(bpio_debug) printf("[Config Request] Hardware reset requested\r\n");
        cmd_mcu_reset();
    }

config_response_error:
    bpio_ConfigurationResponse_start(B);
    // If there was an error, we can set it here.
    if (error) {
        // Set the error message in the response.
        flatbuffers_string_ref_t error_str = flatbuffers_string_create_str(B, error);
        bpio_ConfigurationResponse_error_add(B, error_str);
        if(tud_cdc_n_connected(0)) printf("%s\r\n", error);
    }
    bpio_ConfigurationResponse_ref_t config_response = bpio_ConfigurationResponse_end(B);
    
    // add to packet wrapper
    bpio_ResponsePacket_start_as_root(B);
    bpio_ResponsePacket_contents_ConfigurationResponse_add(B, config_response);
    bpio_ResponsePacket_end_as_root(B);            
    send_packet(B);
}



uint32_t bpio_hwspi_transaction_test(struct bpio_data_request_t *request, flatbuffers_uint8_vec_t data_write, uint8_t *data_read) {
    if(request->debug) printf("[SPI] Performing transaction\r\n");

    if(request->start_main||request->start_alt) {
        // CS active
        if(request->debug) printf("[SPI] CS active\r\n");
        //mode_config.read_with_write=request->start_alt;
        spi_set_cs(M_SPI_SELECT);
    }

    if(request->bytes_write > 0) {
        if(request->debug) printf("[SPI] Writing %d bytes\r\n", request->bytes_write);
        //write data (how to handle write with read?)
        //maybe return all the wwr bytes, then the read bytes?
        for(size_t i = 0; i < request->bytes_write; i++) {
            uint8_t read_byte = hwspi_write_read(flatbuffers_uint8_vec_at(data_write, i));
        }
    }

    if(request->bytes_read > 0) {
        if(request->debug) printf("[SPI] Reading %d bytes\r\n", request->bytes_read);
        // read data
        uint8_t *data_buf = (uint8_t *)request->data_buf;
        for(uint32_t i = 0; i < request->bytes_read; i++) {
            data_read[i] = (uint8_t)hwspi_write_read(0xFF); // send dummy byte
        } 
    }

    if(request->stop_main || request->stop_alt) {
        // CS inactive
        if(request->debug) printf("[SPI] CS inactive\r\n");
        spi_set_cs(M_SPI_DESELECT);
    }

    return false;
}

uint32_t data_request(bpio_RequestPacket_table_t packet, flatcc_builder_t *B) {
    bpio_DataRequest_table_t data_request = (bpio_DataRequest_table_t) bpio_RequestPacket_contents(packet);
    test_assert(data_request != 0);
    const char *error = NULL;
                
    // Check if data_write is present and get its value.
    flatbuffers_uint8_vec_t data_write;
    uint16_t data_write_len = 0;
    if(bpio_DataRequest_data_write_is_present(data_request)) {
        data_write = bpio_DataRequest_data_write(data_request);
        data_write_len = flatbuffers_uint8_vec_len(data_write);
    }

    struct bpio_data_request_t request = {
        .debug = bpio_debug,
        .start_main = bpio_DataRequest_start_main(data_request),
        .start_alt = bpio_DataRequest_start_alt(data_request),
        .bytes_write = data_write_len, // Use the length of the data write vector
        .bytes_read = bpio_DataRequest_bytes_read(data_request),
        //.data_buf = data_buf, // Initialize with the buffer
        .stop_main = bpio_DataRequest_stop_main(data_request),
        .stop_alt = bpio_DataRequest_stop_alt(data_request)
    };

    if(bpio_debug){
        printf("[Data Request] Start main condition: %s\r\n", request.start_main ? "true" : "false");
        printf("[Data Request] Start alternate condition: %s\r\n", request.start_alt ? "true" : "false");
        printf("[Data Request] Bytes to write: %d\r\n", request.bytes_write);
        printf("[Data Request] Bytes to read: %d\r\n", request.bytes_read);
        printf("[Data Request] Stop main condition: %s\r\n", request.stop_main ? "true" : "false");
        printf("[Data Request] Stop alternate condition: %s\r\n", request.stop_alt ? "true" : "false");
    }

    //**************TIME END: 40uS
    bpio_DataResponse_start(B);
    bpio_DataResponse_data_read_start(B);
    size_t data_buf_size = request.bytes_read;
    uint8_t *data_read = bpio_DataResponse_data_read_extend(B, data_buf_size); // Reserve space for data read

    //if(bpio_debug) printf("[Data Request] Protocol request\r\n");
    //if(modes[system_config.mode].bpio_handler(&request)){
    if(bpio_hwspi_transaction_test(&request, data_write, data_read)) {
        bpio_DataResponse_data_read_truncate(B, 0); 
        static const char* request_error_msg = "Protocol request failed";
        if(bpio_debug) printf("[Data Request] %s\r\n", request_error_msg);
        error = request_error_msg;
    }
    bpio_DataResponse_data_read_end(B); // End the data read vector
        
    if (bpio_debug && request.bytes_read > 0 && !error) {
        printf("[Data Request] Returning read %d bytes\r\n", request.bytes_read);
    }

data_response_error:
    if (error) {
        // Set the error message in the response.
        flatbuffers_string_ref_t error_str = flatbuffers_string_create_str(B, error);
        bpio_DataResponse_error_add(B, error_str);
        if(bpio_debug) printf("[Data Request] Error: %s\r\n", error);
    }

    bpio_DataResponse_ref_t data_response = bpio_DataResponse_end(B);
    // add to packet wrapper
    bpio_ResponsePacket_start_as_root(B);
    bpio_ResponsePacket_contents_DataResponse_add(B, data_response);
    bpio_ResponsePacket_end_as_root(B);
    send_packet(B);
}

struct _bpio_function_t {
    uint32_t (*func)(bpio_RequestPacket_table_t packet, flatcc_builder_t *B);
};

const static struct _bpio_function_t bpio_handlers[]={
    [bpio_RequestPacketContents_NONE] = { .func = NULL }, // No handler for unknown packets
    [bpio_RequestPacketContents_StatusRequest] = { .func = status_request },
    [bpio_RequestPacketContents_ConfigurationRequest] = { .func = configuration_request },
    [bpio_RequestPacketContents_DataRequest] = { .func = data_request },
};

void error_response(const char *error_msg, flatcc_builder_t *B) {
    if(bpio_debug) printf("[Error Response] %s\r\n", error_msg);
    flatcc_builder_reset(B);//25uS

    flatbuffers_string_ref_t error_str = flatbuffers_string_create_str(B, error_msg);
    bpio_ErrorResponse_start(B);
    bpio_ErrorResponse_error_add(B, error_str);
    bpio_ErrorResponse_ref_t error_response = bpio_ErrorResponse_end(B);
    
    bpio_ResponsePacket_start_as_root(B);
    bpio_ResponsePacket_contents_ErrorResponse_add(B, error_response);
    bpio_ResponsePacket_end_as_root(B);
    send_packet(B);
}

flatcc_builder_t builder, *B;

void dirtyproto_mode_setup(void) {
    B = &builder;
    // Initialize the builder
    if(flatcc_builder_init(B)==-1) {
        //if(bpio_debug) printf("[BPIO] Error initializing flatcc builder\r\n");
    }
    #if !USB_QUEUE
    system_config.binmode_usb_rx_queue_enable = false;
    system_config.binmode_usb_tx_queue_enable = false;   
    #endif 
}

// handler needs to be cooperative multitasking until mode is enabled
void dirtyproto_mode(void) {
    uint8_t buf[500];

    if (!tud_cdc_n_available(CDC_INTF)) return; // No data available, exit early 

    bpio_debug = (system_config.bpio_debug_enable && tud_cdc_n_connected(0));
    
    // Read flatbuffer data with pointer arithmetic
    uint8_t *buf_ptr = buf;
    uint32_t len = 0;
    uint32_t timeout = time_us_32();
    while (true) {
        if (tud_cdc_n_available(CDC_INTF)) {
            // Read up to the maximum buffer size minus the current pointer position
            uint32_t bytes_remaining = sizeof(buf) - (buf_ptr - buf);
            uint32_t read_bytes = tud_cdc_n_read(CDC_INTF, buf_ptr, bytes_remaining);
            len += read_bytes;
            // search the next read_bytes of the buffer for the COBS delimiter
            for (uint32_t i = 0; i < read_bytes; i++) {
                if (buf_ptr[i] == 0x00) { // COBS delimiter
                    if (bpio_debug) printf("[BPIO] COBS delimiter found, stopping read\r\n");
                    goto bpio_mode_read_end;
                }
            }

            //error if buffer is full
            if (len >= sizeof(buf)) {
                if(bpio_debug) printf("[BPIO] Error: Flatbuffer buffer overflow, buffer size %zu\r\n", sizeof(buf));
                error_response("Flatbuffer buffer overflow", B);
                return;
            }

            //advance pointer
            buf_ptr += read_bytes;
        }
        
        if (time_us_32() - timeout > 500000) { // Timeout after 500ms
            if(bpio_debug) printf("[BPIO] Timeout waiting for flatbuffer data\r\n");
            error_response("Timeout waiting for flatbuffer data", B);
            return;
        }
    } 

bpio_mode_read_end:           
    if(bpio_debug) printf("[BPIO] Flatbuffer data read complete, total length: %d\r\n", len);
    if(bpio_debug) printf("[BPIO] RX packet %dus\r\n", time_us_32() - timeout);

    // nanocobs decode the buffer
    size_t decoded_len;
    timeout = time_us_32();
    cobs_ret_t const cobs_result = cobs_decode(buf, len, buf, sizeof(buf), &decoded_len);
    if(bpio_debug) printf("[COBS] Decoded in %dus\r\n", time_us_32() - timeout);
    if(cobs_result != COBS_RET_SUCCESS) {
        if(bpio_debug) printf("[BPIO] Error: COBS decode failed\r\n");
        error_response("COBS decode failed", B);
        return;
    }
    
    // Verify the flatbuffer packet (this will throw an error if invalid)
    timeout = time_us_32();
    int ret = bpio_RequestPacket_verify_as_root(buf, 500); 
    if(bpio_debug) printf("[BPIO] Flatbuffer verify in %dus\r\n", time_us_32() - timeout);
    if(ret){
        if(bpio_debug){
            printf("[BPIO] Error: Invalid flatbuffer, verify returned %s\r\n", flatcc_verify_error_string(ret));
        }
        error_response("Invalid flatbuffer", B);
        return;
    }
    
    timeout = time_us_32();
    bpio_RequestPacket_table_t packet = bpio_RequestPacket_as_root(buf); //7uS
    if(bpio_debug) printf("[BPIO] Flatbuffer packet parsed in %dus\r\n", time_us_32() - timeout);
    if(packet == 0) {
        error_response("Invalid table received", B);
        return;
    }

    timeout = time_us_32();
    uint8_t packet_type = bpio_RequestPacket_contents_type_get(packet);
    if(bpio_debug) printf("[BPIO] Packet type in %dus\r\n", time_us_32() - timeout);
    if(bpio_debug) printf("[BPIO] Packet Type: %d\r\n", packet_type);
    if(packet_type >= count_of(bpio_handlers) && bpio_handlers[packet_type].func) {
        error_response("Unknown packet type received", B);
    }

    // build response    
    //flatcc_builder_t builder, *B;
    //B = &builder;
    //flatcc_builder_init(B);
    // Call the handler function for this packet type.
    timeout = time_us_32();
    flatcc_builder_reset(B);//25uS
    if(bpio_debug) printf("[BPIO] Reset builder in %dus\r\n", time_us_32() - timeout);
    timeout = time_us_32();
    bpio_handlers[packet_type].func(packet, B); //450uS
    if(bpio_debug) printf("[BPIO] Handler function executed in %dus\r\n", time_us_32() - timeout);
    //printf("[BPIO] Packet processed in %d us\r\n", time_end - time_start);
    //flatcc_builder_reset(B);
    // build next buffer.
    //flatcc_builder_clear(B);    

}
