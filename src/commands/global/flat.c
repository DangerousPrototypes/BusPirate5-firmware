#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "pirate.h"
#include "system_config.h"
#include "command_struct.h"
#include "fatfs/ff.h"
#include "pirate/file.h"
#include "ui/ui_prompt.h"
#include "ui/ui_parse.h"
#include "ui/ui_term.h"
#include "ui/ui_help.h"
#include "pirate/storage.h"
#include "pirate/mem.h"
#include "ui/ui_cmdln.h"
//#include "pirate/storage.h"
#include "ui/ui_hex.h"
//#include "monster_builder.h" // Generated by `flatcc`.
#include "bpio_builder.h" // Generated by `flatcc`.

// Convenient namespace macro to manage long namespace prefix.
#undef ns
// Specified in the schema.
//#define ns(x) FLATBUFFERS_WRAP_NAMESPACE(MyGame_Sample, x) 
#define ns_bpio(x) FLATBUFFERS_WRAP_NAMESPACE(BPIO2, x)

// A helper to simplify creating vectors from C-arrays.
#define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))

// This allows us to verify result in optimized builds.
#define test_assert(x) do { if (!(x)) { assert(0); return -1; }} while(0)

enum PacketType{
  I2CRWRequest = 0, // I2C Read/Write Request
  I2CResponse = 1, // I2C Response
};

int read_flat(const void *buffer){
    // get data out of flatbuffer, print it
    ns_bpio(Packet_table_t) packet = ns_bpio(Packet_as_root(buffer));
    // Make sure the packet is accessible.
    test_assert(packet != 0);
    uint8_t packet_type = ns_bpio(Packet_type(packet));
    printf("Packet Type: %d\r\n", packet_type);
    if(packet_type==I2CRWRequest){
        ns_bpio(I2CRWRequest_table_t) i2c_rw_request = (ns_bpio(I2CRWRequest_table_t)) ns_bpio(Packet_contents(packet));
        bool start = ns_bpio(I2CRWRequest_i2cstart(i2c_rw_request));
        uint8_t addr = ns_bpio(I2CRWRequest_i2caddr(i2c_rw_request));
        // Get the data vector.
        //ns_bpio(uint8_t_vec_t) data = ns_bpio(Bpio_i2cdata(bpio));
        uint32_t readbytes = ns_bpio(I2CRWRequest_i2creadbytes(i2c_rw_request));
        bool stop = ns_bpio(I2CRWRequest_i2cstop(i2c_rw_request));
        printf("Start: %s, Address: 0x%02X, Read Bytes: %d, Stop: %s\r\n",
               start ? "true" : "false", addr, readbytes, stop ? "true" : "false");
    }
}

void flat_handler(struct command_result* res) {
    uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    size_t data_size = c_vec_len(data);
    flatcc_builder_t builder, *B;
    B = &builder;
    flatcc_builder_init(B);
#if 0
    ns_bpio(Packet_start_as_root(B));
    ns_bpio(Packet_contents_start(B));
    ns_bpio(Packet_contents_type_add(B, ns_bpio(PacketContents_I2CRWRequest))); // Set the packet contents type to I2CRWRequest.
    // alternate approach
    ns_bpio(I2CRWRequest_start(B));
    ns_bpio(I2CRWRequest_i2caddr_add(B, 0x50)); // Set the I2C address.
    ns_bpio(I2CRWRequest_i2cstart_add(B, true)); // Set the start condition.
    ns_bpio(I2CRWRequest_i2cstop_add(B, true)); //   Set the stop condition.
    ns_bpio(I2CRWRequest_i2cdata_create(B, data, c_vec_len(data))); // Set the payload data.
    ns_bpio(I2CRWRequest_i2creadbytes_add(B, 10)); // Set the number of bytes to read.
    ns_bpio(I2CRWRequest_end(B));
    // Create a packet with the I2C request.
    ns_bpio(Packet_start(B));
    ns_bpio(Packet_contents_I2CRWRequest_add(B, ns_bpio(I2CRWRequest_clone(B, ns_bpio(I2CRWRequest_as_root(B)))))); // Add the I2C request to the packet.
    ns_bpio(Packet_end(B));
#else

    flatbuffers_bool_t start = true; // Start condition.
    uint8_t addr = 0x50; // Device address (Bus Pirate automatically will set read/write bit).

    flatbuffers_uint8_vec_ref_t payload = flatbuffers_uint8_vec_create(B, data, c_vec_len(data));
    uint32_t readbytes = 10; // Number of bytes to read.
    flatbuffers_bool_t stop = true; // Stop condition.
    ns_bpio(I2CRWRequest_ref_t) i2c_rw_request = ns_bpio(I2CRWRequest_create(B, start, addr, payload, readbytes, stop));

    ns_bpio(Packet_start_as_root(B));
    ns_bpio(Packet_contents_I2CRWRequest_add(B, i2c_rw_request));
    ns_bpio(Packet_end_as_root(B));
 #endif   
    uint8_t *buf;
    size_t size;
    buf = flatcc_builder_finalize_buffer(B, &size);
    
    printf("Flatbuffers buffer size: %zu bytes\r\n", size);
    if(read_flat(buf)==-1) {
        printf("Error reading flatbuffer.\r\n");
    } else {
        printf("Flatbuffer read successfully.\r\n");
    }
    free(buf);

    // Optionally reset builder to reuse builder without deallocating
    // internal stack and heap.
    flatcc_builder_reset(B);
    // build next buffer.
    // ...
    // Cleanup.
    flatcc_builder_clear(B);         
}