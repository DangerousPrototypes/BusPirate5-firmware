/*
 * This file is part of the Bus Pirate project (http://code.google.com/p/the-bus-pirate/).
 *
 * Written and maintained by the Bus Pirate project.
 *
 * To the extent possible under law, the project has
 * waived all copyright and related or neighboring rights to Bus Pirate. This
 * work is published from United States.
 *
 * For details see: http://creativecommons.org/publicdomain/zero/1.0/.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

/* Binary access modes for Bus Pirate scripting */

// #include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "pirate.h"
#include "queue.h"
#include "usb_rx.h"
#include "usb_tx.h"
#include "pirate.h"
// #include "sump.h"
#include "command_struct.h" //needed for same reason as bytecode and needs same fix
#include "bytecode.h"
#include "modes.h"
#include "binio_helpers.h"
#include "tusb.h"
#include "binmode/binio.h"
#include "system_config.h"

struct _binmode_struct {
    uint32_t (*func)(uint8_t* data);
    int arg_count;
};

enum {
    BM_RESET = 0,
    BM_DEBUG_LEVEL,        // 1
    BM_POWER_EN,           // 2
    BM_POWER_DIS,          // 3
    BM_PULLUP_EN,          // 4
    BM_PULLUP_DIS,         // 5
    BM_LIST_MODES,         // 6
    BM_CHANGE_MODE,        // 7
    BM_INFO,               // 8
    BM_VERSION_HW,         // 9
    BM_VERSION_FW,         // 10
    BM_BITORDER_MSB,       // 11
    BM_BITORDER_LSB,       // 12
    BM_AUX_DIRECTION_MASK, // 13
    BM_AUX_READ,           // 14
    BM_AUX_WRITE_MASK,     // 15
    BM_ADC_SELECT,         // 16
    BM_ADC_READ,           // 17
    BM_ADC_RAW,            // 18
    BM_PWM_EN,             // 19
    BM_PWM_DIS,            // 20
    BM_PWM_RAW,            // 21
    // BM_PWM_ACTUAL_FREQ, //22
    BM_FREQ,            // 23
    BM_FREQ_RAW,        // 24
    BM_DELAY_US,        // 25
    BM_DELAY_MS,        // 26
    BM_BOOTLOADER,      // 27
    BM_RESET_BUSPIRATE, // 28
    BM_PRINT_STRING,    // 29
    BM_CHANGE_BINMODE,
    // BM_BINMODE_VERSION, //30
    // self test
    // disable all interrupt
    // enable all interrupt
    // LEDs?

    BM_CONFIG,
    BM_WRITE,
    BM_START,
    BM_START_ALT,
    BM_STOP,
    BM_STOP_ALT,
    BM_READ,
    BM_CLKH,
    BM_CLKL,
    BM_TICK,
    BM_DATH,
    BM_DATL,
    BM_BITR,
};

static const struct _binmode_struct binmode_commands[] = {
    [BM_RESET] = { &binmode_reset, 0 },
    [BM_DEBUG_LEVEL] = { &binmode_debug_level, 1 },
    [BM_POWER_EN] = { &binmode_psu_enable, 4 },
    [BM_POWER_DIS] = { &binmode_psu_disable, 0 },
    [BM_PULLUP_EN] = { &binmode_pullup_enable, 0 },
    [BM_PULLUP_DIS] = { &binmode_pullup_disable, 0 },
    [BM_LIST_MODES] = { &mode_list, 0 },
    [BM_CHANGE_MODE] = { &mode_change, -1 },
    [BM_INFO] = { &binmode_info, 0 },
    [BM_VERSION_HW] = { &binmode_hwversion, 0 },
    [BM_VERSION_FW] = { &binmode_fwversion, 0 },
    [BM_BITORDER_MSB] = { &binmode_bitorder_msb, 0 },
    [BM_BITORDER_LSB] = { &binmode_bitorder_lsb, 0 },
    [BM_AUX_DIRECTION_MASK] = { &binmode_aux_direction_mask, 2 },
    [BM_AUX_READ] = { &binmode_aux_read, 0 },
    [BM_AUX_WRITE_MASK] = { &binmode_aux_write_mask, 2 },
    [BM_ADC_SELECT] = { &binmode_adc_select, 1 },
    [BM_ADC_READ] = { &binmode_adc_read, 0 },
    [BM_ADC_RAW] = { &binmode_adc_raw, 0 },
    [BM_PWM_EN] = { &binmode_pwm_enable, 6 },
    [BM_PWM_DIS] = { &binmode_pwm_disable, 1 },
    [BM_PWM_RAW] = { &binmode_pwm_raw, 7 },
    [BM_FREQ] = { &binmode_freq, 2 },
    [BM_FREQ_RAW] = { &binmode_freq_raw, 2 },
    [BM_DELAY_US] = { &binmode_delay_us, 1 },
    [BM_DELAY_MS] = { &binmode_delay_ms, 1 },
    [BM_BOOTLOADER] = { &binmode_bootloader, 0 },
    [BM_RESET_BUSPIRATE] = { &binmode_reset_buspirate, 0 },
    [BM_PRINT_STRING] = { 0, 0 },
    [BM_CHANGE_BINMODE] = { &binmode_change_binmode, 1 },
    // mode commands
    [BM_CONFIG] = { &binmode_config, 0 },
    [BM_WRITE] = { &binmode_write, 1 },
    [BM_START] = { &binmode_start, 0 },
    [BM_START_ALT] = { &binmode_start_alt, 0 },
    [BM_STOP] = { &binmode_stop, 0 },
    [BM_STOP_ALT] = { &binmode_stop_alt, 0 },
    [BM_READ] = { &binmode_read, 0 },
    [BM_CLKH] = { &binmode_clkh, 0 },
    [BM_CLKL] = { &binmode_clkl, 0 },
    [BM_TICK] = { &binmode_tick, 0 },
    [BM_DATH] = { &binmode_dath, 0 },
    [BM_DATL] = { &binmode_datl, 0 },
    [BM_BITR] = { &binmode_bitr, 0 },
};

enum binmode_statemachine {
    BINMODE_IDLE = 0,
    BINMODE_HEADER1,
    BINMODE_PACKET
};

const char dirtyproto_mode_name[] = "Binmode test framework";

#include "bpio_builder.h" // Generated by `flatcc`.

// A helper to simplify creating vectors from C-arrays.
#define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))

// This allows us to verify result in optimized builds.
#define test_assert(x) do { if (!(x)) { assert(0); return -1; }} while(0)


static bool mode_change_new(const char *mode_name) {
    // compare mode name to modes.protocol_name
    for (uint8_t i = 0; i < count_of(modes); i++) {
        if (strcasecmp(mode_name, modes[i].protocol_name) == 0) {
            modes[system_config.mode].protocol_cleanup();
            system_config.mode = i;
            modes[system_config.mode].protocol_setup_exc();
            if (binmode_debug) {
                printf("[MODE] Changed to %s\r\n", modes[system_config.mode].protocol_name);
            }
            return false;
        }
    }
    return true;
}





uint32_t status_request(bpio_RequestPacket_table_t packet, flatcc_builder_t *B) {
    bpio_StatusRequest_table_t status_request = (bpio_StatusRequest_table_t) bpio_RequestPacket_contents(packet);
    test_assert(status_request != 0);
    uint8_t id = bpio_StatusRequest_id(status_request);
    const char* name = bpio_StatusRequest_name(status_request);
    printf("Status Request: id=%d, name=%s\r\n", id, name ? name : "NULL");

    //if name is not null, then search for the mode, if valid, then change modes
    bool error = false;
    if( name != NULL && name[0] != '\0') {
        if (mode_change_new(name)) {
            printf("Error: Invalid mode name '%s'\r\n", name);
            error = true;
        }
        uint8_t mode_config_type = bpio_StatusRequest_configuration_type_get(status_request);
        printf("Mode configuration type: %d\r\n", mode_config_type);
        if (mode_config_type != bpio_ModeConfiguration_I2CConfig) {
            printf("Error: Unsupported mode configuration type %d\r\n", mode_config_type);
            error = true;
        }
    }

    const char error_message[]="Invalid mode name";

    printf("Sending list of modes\r\n");
    // send a list of modes back
    bpio_StatusResponse_start(B);
    bpio_StatusResponse_modes_start(B);
    for (uint8_t i = 0; i < count_of(modes); i++) {
        flatbuffers_string_ref_t name = flatbuffers_string_create_str(B, modes[i].protocol_name);
        bpio_StatusResponse_modes_push_create(B, i, name);
    }            
    bpio_StatusResponse_modes_end(B);
    bpio_StatusResponse_ref_t status_response = bpio_StatusResponse_end(B);
    // add to packet wrapper
    bpio_ResponsePacket_start_as_root(B);
    bpio_ResponsePacket_contents_StatusResponse_add(B, status_response);
    bpio_ResponsePacket_end_as_root(B);            
    // send the packet
    uint8_t* buf;
    size_t len = flatcc_builder_get_buffer_size(B);
    buf = flatcc_builder_finalize_buffer(B, &len);
    printf("Sending StatusResponse packet with length %d\r\n", len);
    //send two byte length header
    uint8_t header[2];
    header[0] = len & 0xFF; // LSB
    header[1] = (len >> 8) & 0xFF; // MSB
    bin_tx_fifo_put(header[0]);
    bin_tx_fifo_put(header[1]);
    for(size_t i = 0; i < len; i++) {
        bin_tx_fifo_put(buf[i]);
    }
}

uint32_t data_request(bpio_RequestPacket_table_t packet, flatcc_builder_t *B) {
    bpio_DataRequest_table_t data_request = (bpio_DataRequest_table_t) bpio_RequestPacket_contents(packet);
    bool start = bpio_DataRequest_dstart(data_request);
    bool start_alt = bpio_DataRequest_dstart_alt(data_request);
    uint8_t addr = bpio_DataRequest_daddr(data_request);
    // Get the data vector.
    //bpio_uint8_t_vec_t) data = bpio_Bpio_i2cdata(bpio));
    uint32_t readbytes = bpio_DataRequest_dreadbytes(data_request);
    bool stop = bpio_DataRequest_dstop(data_request);
    bool stop_alt = bpio_DataRequest_dstop_alt(data_request);
    printf("Data Request: Start: %s, Start Alt: %s, Address: 0x%02X, Read Bytes: %d, Stop: %s, Stop Alt: %s\r\n",
            start ? "true" : "false", start_alt ? "true" : "false", addr, readbytes,
            stop ? "true" : "false", stop_alt ? "true" : "false");
}

struct _bpio_function_t {
    uint32_t (*func)(bpio_RequestPacket_table_t packet, flatcc_builder_t *B);
};

const static struct _bpio_function_t bpio_handlers[]={
    [bpio_RequestPacketContents_StatusRequest] = { .func = status_request },
    [bpio_RequestPacketContents_DataRequest] = { .func = data_request },
};

// handler needs to be cooperative multitasking until mode is enabled
void dirtyproto_mode(void) {
    binmode_debug = true;
    static uint8_t binmode_state = BINMODE_IDLE;

    uint8_t buf[500];
    static uint32_t len=0;
    char c; 
    
    if (!bin_rx_fifo_try_get(&c)) return;

    switch (binmode_state) {
        case BINMODE_IDLE:
            len=c;
            binmode_state = BINMODE_HEADER1;
            break;
        case BINMODE_HEADER1:
            len |= c << 8;
            if(len==0 || len>sizeof(buf)){
                printf("Flatbuffer size error: %d\r\n", len);
                binmode_state = BINMODE_IDLE;
                break;
            }
            printf("Flatbuffer length: %d\r\n", len);         
            binmode_state = BINMODE_PACKET;
            //break;
        case BINMODE_PACKET:
            //get len bytes
            for(uint32_t i=0; i<len; i++) {
                bin_rx_fifo_get_blocking(&c);
                buf[i] = c; // Store in reverse order
            }
            printf("Flatbuffer received, length: %d\r\n", len);
            bpio_RequestPacket_table_t packet = bpio_RequestPacket_as_root(buf);
            if(packet == 0) {
                printf("Error: Invalid packet received\r\n");
                binmode_state = BINMODE_IDLE; // Reset state on error
                return;
            }
            uint8_t packet_type = bpio_RequestPacket_contents_type_get(packet);
            printf("Packet Type: %d\r\n", packet_type);
            if (packet_type < count_of(bpio_handlers) && bpio_handlers[packet_type].func) {
                // build response    
                flatcc_builder_t builder, *B;
                B = &builder;
                flatcc_builder_init(B);
                // Call the handler function for this packet type.
                bpio_handlers[packet_type].func(packet, B);
                //flatcc_builder_reset(B);
                // build next buffer.
                // ...
                // Cleanup.
                flatcc_builder_clear(B);    
            } else {
                printf("Unknown packet type: %d\r\n", packet_type);
            }
            binmode_state = BINMODE_IDLE; // Reset state after processing the packet
            break;
        default:
            printf("Unknown binmode state: %d\r\n", binmode_state);
            binmode_state = BINMODE_IDLE;
            break;
    }

}
