/*
 * This file is part of the Bus Pirate project (http://code.google.com/p/the-bus-pirate/).
 *
 * Written and maintained by the Bus Pirate project.
 *
 * To the extent possible under law, the project has
 * waived all copyright and related or neighboring rights to Bus Pirate. This
 * work is published from United States.
 *
 * For details see: http://creativecommons.org/publicdomain/zero/1.0/.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

/* Binary access modes for Bus Pirate scripting */

// #include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "pirate.h"
#include "queue.h"
#include "usb_rx.h"
#include "usb_tx.h"
#include "pirate.h"
// #include "sump.h"
#include "command_struct.h" //needed for same reason as bytecode and needs same fix
#include "bytecode.h"
#include "modes.h"
#include "binio_helpers.h"
#include "tusb.h"
#include "binmode/binio.h"
#include "system_config.h"
#include "pirate/amux.h"
#include "commands/global/w_psu.h"
#include "pirate/bio.h"
#include "commands/global/p_pullups.h"
#include "pirate/psu.h"

struct _binmode_struct {
    uint32_t (*func)(uint8_t* data);
    int arg_count;
};

enum {
    BM_RESET = 0,
    BM_DEBUG_LEVEL,        // 1
    BM_POWER_EN,           // 2
    BM_POWER_DIS,          // 3
    BM_PULLUP_EN,          // 4
    BM_PULLUP_DIS,         // 5
    BM_LIST_MODES,         // 6
    BM_CHANGE_MODE,        // 7
    BM_INFO,               // 8
    BM_VERSION_HW,         // 9
    BM_VERSION_FW,         // 10
    BM_BITORDER_MSB,       // 11
    BM_BITORDER_LSB,       // 12
    BM_AUX_DIRECTION_MASK, // 13
    BM_AUX_READ,           // 14
    BM_AUX_WRITE_MASK,     // 15
    BM_ADC_SELECT,         // 16
    BM_ADC_READ,           // 17
    BM_ADC_RAW,            // 18
    BM_PWM_EN,             // 19
    BM_PWM_DIS,            // 20
    BM_PWM_RAW,            // 21
    // BM_PWM_ACTUAL_FREQ, //22
    BM_FREQ,            // 23
    BM_FREQ_RAW,        // 24
    BM_DELAY_US,        // 25
    BM_DELAY_MS,        // 26
    BM_BOOTLOADER,      // 27
    BM_RESET_BUSPIRATE, // 28
    BM_PRINT_STRING,    // 29
    BM_CHANGE_BINMODE,
    // BM_BINMODE_VERSION, //30
    // self test
    // disable all interrupt
    // enable all interrupt
    // LEDs?

    BM_CONFIG,
    BM_WRITE,
    BM_START,
    BM_START_ALT,
    BM_STOP,
    BM_STOP_ALT,
    BM_READ,
    BM_CLKH,
    BM_CLKL,
    BM_TICK,
    BM_DATH,
    BM_DATL,
    BM_BITR,
};

static const struct _binmode_struct binmode_commands[] = {
    [BM_RESET] = { &binmode_reset, 0 },
    [BM_DEBUG_LEVEL] = { &binmode_debug_level, 1 },
    [BM_POWER_EN] = { &binmode_psu_enable, 4 },
    [BM_POWER_DIS] = { &binmode_psu_disable, 0 },
    [BM_PULLUP_EN] = { &binmode_pullup_enable, 0 },
    [BM_PULLUP_DIS] = { &binmode_pullup_disable, 0 },
    [BM_LIST_MODES] = { &mode_list, 0 },
    [BM_CHANGE_MODE] = { &mode_change, -1 },
    [BM_INFO] = { &binmode_info, 0 },
    [BM_VERSION_HW] = { &binmode_hwversion, 0 },
    [BM_VERSION_FW] = { &binmode_fwversion, 0 },
    [BM_BITORDER_MSB] = { &binmode_bitorder_msb, 0 },
    [BM_BITORDER_LSB] = { &binmode_bitorder_lsb, 0 },
    [BM_AUX_DIRECTION_MASK] = { &binmode_aux_direction_mask, 2 },
    [BM_AUX_READ] = { &binmode_aux_read, 0 },
    [BM_AUX_WRITE_MASK] = { &binmode_aux_write_mask, 2 },
    [BM_ADC_SELECT] = { &binmode_adc_select, 1 },
    [BM_ADC_READ] = { &binmode_adc_read, 0 },
    [BM_ADC_RAW] = { &binmode_adc_raw, 0 },
    [BM_PWM_EN] = { &binmode_pwm_enable, 6 },
    [BM_PWM_DIS] = { &binmode_pwm_disable, 1 },
    [BM_PWM_RAW] = { &binmode_pwm_raw, 7 },
    [BM_FREQ] = { &binmode_freq, 2 },
    [BM_FREQ_RAW] = { &binmode_freq_raw, 2 },
    [BM_DELAY_US] = { &binmode_delay_us, 1 },
    [BM_DELAY_MS] = { &binmode_delay_ms, 1 },
    [BM_BOOTLOADER] = { &binmode_bootloader, 0 },
    [BM_RESET_BUSPIRATE] = { &binmode_reset_buspirate, 0 },
    [BM_PRINT_STRING] = { 0, 0 },
    [BM_CHANGE_BINMODE] = { &binmode_change_binmode, 1 },
    // mode commands
    [BM_CONFIG] = { &binmode_config, 0 },
    [BM_WRITE] = { &binmode_write, 1 },
    [BM_START] = { &binmode_start, 0 },
    [BM_START_ALT] = { &binmode_start_alt, 0 },
    [BM_STOP] = { &binmode_stop, 0 },
    [BM_STOP_ALT] = { &binmode_stop_alt, 0 },
    [BM_READ] = { &binmode_read, 0 },
    [BM_CLKH] = { &binmode_clkh, 0 },
    [BM_CLKL] = { &binmode_clkl, 0 },
    [BM_TICK] = { &binmode_tick, 0 },
    [BM_DATH] = { &binmode_dath, 0 },
    [BM_DATL] = { &binmode_datl, 0 },
    [BM_BITR] = { &binmode_bitr, 0 },
};

enum binmode_statemachine {
    BINMODE_IDLE = 0,
    BINMODE_HEADER1,
    BINMODE_PACKET
};

const char dirtyproto_mode_name[] = "Binmode test framework";

#include "bpio_builder.h" // Generated by `flatcc`.
#include "bpio_reader.h"  // Add this for bpio_bool_vec_len and related functions.

// A helper to simplify creating vectors from C-arrays.
#define c_vec_len(V) (sizeof(V)/sizeof((V)[0]))

// This allows us to verify result in optimized builds.
#define test_assert(x) do { if (!(x)) { assert(0); return -1; }} while(0)


static bool mode_change_new(const char *mode_name) {
    // compare mode name to modes.protocol_name
    for (uint8_t i = 0; i < count_of(modes); i++) {
        if (strcasecmp(mode_name, modes[i].protocol_name) == 0) {
            modes[system_config.mode].protocol_cleanup();
            system_config.mode = i;
            modes[system_config.mode].protocol_setup_exc();
            return false;
        }
    }
    return true;
}

static inline void send_packet(flatcc_builder_t *B) {
    uint8_t* buf;
    size_t len = flatcc_builder_get_buffer_size(B);
    buf = flatcc_builder_finalize_buffer(B, &len);
    printf("[Send Packet] Length %d\r\n", len);
    //send two byte length header
    uint8_t header[2];
    header[0] = len & 0xFF; // LSB
    header[1] = (len >> 8) & 0xFF; // MSB
    bin_tx_fifo_put(header[0]);
    bin_tx_fifo_put(header[1]);
    for(size_t i = 0; i < len; i++) {
        bin_tx_fifo_put(buf[i]);
    }
}

uint32_t status_request(bpio_RequestPacket_table_t packet, flatcc_builder_t *B) {
    bpio_StatusRequest_table_t status_request = (bpio_StatusRequest_table_t) bpio_RequestPacket_contents(packet);
    test_assert(status_request != 0);

    bpio_StatusRequestTypes_vec_t query = bpio_StatusRequest_query(status_request);

    uint32_t query_flags=0;
    // Make sure the vector is accessible.
    if(query == 0){ //no query, send all
        query_flags|= 1u<<bpio_StatusRequestTypes_All;
    }else{
        // Iterate through the vector
        printf("[Status Request] Query types: ");
        for (size_t i = 0; i < bpio_StatusRequestTypes_vec_len(query); i++) {
            bpio_StatusRequestTypes_enum_t query_type = bpio_StatusRequestTypes_vec_at(query, i);
            printf("%zu ", query_type);
            // Set the corresponding bit in query_flags
            query_flags |= (1u << query_type);
        }
        printf("\r\n");
    }

    bpio_StatusResponse_start(B);
    if(query_flags & (1u << bpio_StatusRequestTypes_Version)||query_flags & (1u << bpio_StatusRequestTypes_All)) {
        // Send version information
        printf("[Status Request] Version requested\r\n");
        bpio_StatusResponse_hardware_version_major_add(B, BP_FIRMWARE_VERSION_MAJOR);
        bpio_StatusResponse_hardware_version_minor_add(B, BP_FIRMWARE_VERSION_REVISION);
        bpio_StatusResponse_firmware_version_major_add(B, 0);
        bpio_StatusResponse_firmware_version_minor_add(B, 0);
        flatbuffers_string_ref_t git_hash = flatbuffers_string_create_str(B, BP_FIRMWARE_HASH);
        bpio_StatusResponse_firmware_git_hash_add(B, git_hash);
        flatbuffers_string_ref_t firmware_date = flatbuffers_string_create_str(B, BP_FIRMWARE_TIMESTAMP);
        bpio_StatusResponse_firmware_date_add(B, firmware_date);

    }

    //modes_available and current mode
    if(query_flags & (1u << bpio_StatusRequestTypes_Mode) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        printf("[Status Request] Modes available requested\r\n");
        
        flatbuffers_string_ref_t current_mode_name = flatbuffers_string_create_str(B, modes[system_config.mode].protocol_name);
        bpio_StatusResponse_mode_current_add(B, current_mode_name);

        bpio_StatusResponse_modes_available_start(B); // <-- Start the vector!
        for (uint8_t i = 0; i < count_of(modes); i++) {
            flatbuffers_string_ref_t name = flatbuffers_string_create_str(B, modes[i].protocol_name);
            bpio_StatusResponse_modes_available_push(B, name);
        }        
        bpio_StatusResponse_modes_available_end(B); // <-- End the vector!

        bpio_StatusResponse_mode_pin_labels_start(B);
        for (uint8_t i = 0; i < HW_PINS; i++) {
            flatbuffers_string_ref_t label = flatbuffers_string_create_str(B, system_config.pin_labels[i]);
            bpio_StatusResponse_mode_pin_labels_push(B, label);
        }
        bpio_StatusResponse_mode_pin_labels_end(B);
    }

    // led_count
    if(query_flags & (1u << bpio_StatusRequestTypes_LED) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        printf("[Status Request] LED count requested\r\n");
        bpio_StatusResponse_led_count_add(B, RGB_LEN);
    }

    // Pullup status
    if(query_flags & (1u << bpio_StatusRequestTypes_Pullup) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        printf("[Status Request] Pullup status requested\r\n");
        bpio_StatusResponse_pullup_enabled_add(B, system_config.pullup_enabled);
    }

    // PSU status
    if(query_flags & (1u << bpio_StatusRequestTypes_PSU) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        printf("[Status Request] PSU status requested\r\n");
        bpio_StatusResponse_psu_enabled_add(B, system_config.psu);
        bpio_StatusResponse_psu_set_mv_add(B, system_config.psu_voltage/10);
        bpio_StatusResponse_psu_set_ma_add(B, system_config.psu_current_limit/10000);
        uint32_t vout, isense, vreg;
        bool fuse;
        psu_measure(&vout, &isense, &vreg, &fuse);
        bpio_StatusResponse_psu_measured_mv_add(B, vout);
        bpio_StatusResponse_psu_measured_ma_add(B, isense/1000);
        bpio_StatusResponse_psu_current_error_add(B, system_config.psu_current_error);

    }

    //ADC status, return the voltage on IO0...IO7
    if(query_flags & (1u << bpio_StatusRequestTypes_ADC) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        printf("[Status Request] ADC status requested\r\n");
        amux_sweep();
        bpio_StatusResponse_adc_mv_start(B);
        for (uint8_t i = 1; i < 9; i++) {
            bpio_StatusResponse_adc_mv_push(B, hw_pin_voltage_ordered[i]);
        }
        bpio_StatusResponse_adc_mv_end(B);
    }

    // IO status
    if(query_flags & (1u << bpio_StatusRequestTypes_IO) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        printf("[Status Request] IO status requested\r\n");
        // direction is 0-7
        // value is 8-15
        uint32_t pins = gpio_get_all();
        bpio_StatusResponse_io_direction_add(B, (uint8_t)(pins & 0xff)); // Get the first 8 bits for direction
        bpio_StatusResponse_io_value_add(B, (uint8_t)((pins >> 8) & 0xff)); // Get the next 8 bits for value        
    }

    // Disk status
    if(query_flags & (1u << bpio_StatusRequestTypes_Disk) || query_flags & (1u << bpio_StatusRequestTypes_All)) {
        printf("[Status Request] Disk status requested\r\n");
        bpio_StatusResponse_disk_size_mb_add(B, system_config.storage_size * 1000);
        bpio_StatusResponse_disk_used_mb_add(B, 0.0f); //todo: implement disk free space    
    }

    // end status response table
    bpio_StatusResponse_ref_t status_response = bpio_StatusResponse_end(B);
    
    // add to packet wrapper
    bpio_ResponsePacket_start_as_root(B);
    bpio_ResponsePacket_contents_StatusResponse_add(B, status_response);
    bpio_ResponsePacket_end_as_root(B);            
    // send the packet
    send_packet(B);
}


uint32_t configuration_request(bpio_RequestPacket_table_t packet, flatcc_builder_t *B) {
    bpio_ConfigurationRequest_table_t config_request = (bpio_ConfigurationRequest_table_t) bpio_RequestPacket_contents(packet);
    test_assert(config_request != 0);

    const char *error = NULL;

    // does it have mode?
    if(bpio_ConfigurationRequest_mode_is_present(config_request)) {
        // change mode
        const char* mode_str = bpio_ConfigurationRequest_mode_get(config_request);
        if (mode_change_new(mode_str)) {
            static const char *mode_error_msg = "Invalid mode name";
            printf("[Config Request] Error: %s '%s'\r\n", mode_error_msg, mode_str);
            error = mode_error_msg;
            goto config_response_error;
        }
        //todo: configure mode
        printf("[Config Request] Mode changed to '%s'\r\n", mode_str);
    }

    //pullup_enabled
    if(bpio_ConfigurationRequest_pullup_enabled_is_present(config_request)) {
        bool pullup_enabled = bpio_ConfigurationRequest_pullup_enabled_get(config_request);
        uint8_t temp;
        if (pullup_enabled) {
            pullups_enable();
        } else {
            pullups_disable();
        }
        printf("[Config Request] Pull-up resistors %s\r\n", pullup_enabled ? "enabled" : "disabled");
    }

    //psu_enabled
    if(bpio_ConfigurationRequest_psu_enabled_is_present(config_request)) {
        bool psu_enabled = bpio_ConfigurationRequest_psu_enabled_get(config_request);
        if (psu_enabled) {
            
            uint32_t voltage_mv = 3300;
            if(bpio_ConfigurationRequest_psu_set_mv_is_present(config_request)) {
                voltage_mv = bpio_ConfigurationRequest_psu_set_mv_get(config_request);
                //check out of range
                if(voltage_mv < 800 || voltage_mv > 5000) {
                    static const char *voltage_error_msg = "PSU Voltage out of range (800-5000 mV)";
                    printf("[Config Request] Error: %s (%d mV)\r\n", voltage_error_msg, voltage_mv);
                    error = voltage_error_msg;
                    goto config_response_error;
                }
            }
            
            uint32_t current_ma = 300; // default
            bool current_limit_override = false;
            if(bpio_ConfigurationRequest_psu_set_ma_is_present(config_request)) {
                uint32_t current_ma = bpio_ConfigurationRequest_psu_set_ma_get(config_request);
                if(current_ma==0) {
                    current_limit_override = true; // 0 means no limit
                    printf("[Config Request] PSU current limit override enabled\r\n");
                }else{
                    //check out of range
                    if(current_ma < 0 || current_ma > 500) {
                        static const char *current_error_msg = "PSU Current out of range (0-500 mA)";
                        printf("[Config Request] Error: %s (%d mA)\r\n", current_error_msg, current_ma);
                        error = current_error_msg;
                        goto config_response_error;
                    }
                }
            }

            printf("[Config Request] PSU Voltage: %f, Current: %f, Override: %s\r\n", (float)voltage_mv/1000.0f, (float)current_ma, current_limit_override?"true":"false");
            
            uint8_t psu_error = psucmd_enable((float)voltage_mv/1000.0f, (float)current_ma, current_limit_override);
            if (psu_error) {
                static const char *psu_error_msg = "Power supply initialization failed";
                printf("[Config Request] Error: %s (%d)\r\n", psu_error_msg, psu_error);
                error = psu_error_msg;
                goto config_response_error;
            }
        } else {
            psucmd_disable();
        }
        printf("[Config Request] Power supply %s\r\n", psu_enabled ? "enabled" : "disabled");
    }
   
    //io_direction
    //TODO: this needs to respect any in-use pins (check system_config?)
    if(bpio_ConfigurationRequest_io_direction_mask_is_present(config_request)){
        printf("[Config Request] IO direction mask is present\r\n");
    }
    if(bpio_ConfigurationRequest_io_direction_is_present(config_request)) {
        printf("[Config Request] IO direction \r\n");
        if(!bpio_ConfigurationRequest_io_direction_mask_is_present(config_request)){
            static const char *io_direction_error_msg = "IO direction mask is missing";
            printf("[Config Request] Error: %s\r\n", io_direction_error_msg);
            error = io_direction_error_msg;
            goto config_response_error;
        }else{
            uint8_t io_direction_mask = bpio_ConfigurationRequest_io_direction_mask_get(config_request);
            uint8_t io_direction = bpio_ConfigurationRequest_io_direction_get(config_request);
            for(uint8_t i = 0; i < 8; i++) {
                if(io_direction_mask & (1u << i)) {
                    //set the direction
                    if(io_direction & (1u << i)) {
                        // first set the buffer to output
                        gpio_put(i, BUFDIR_OUTPUT);
                        // now set pin to output
                        gpio_set_dir(i+8, GPIO_OUT);
                        printf("[Config Request] IO%d set to output\r\n", i);
                    }else{
                        // first set the pin to input
                        gpio_set_dir(i+8, GPIO_IN);
                        // now set buffer to input
                        gpio_put(i, BUFDIR_INPUT);
                        printf("[Config Request] IO%d set to input\r\n", i);
                    }
                }
            }
        }
    }

    //io_value
    if(bpio_ConfigurationRequest_io_value_is_present(config_request)) {
        printf("[Config Request] IO value \r\n");
        if(!bpio_ConfigurationRequest_io_value_mask_is_present(config_request)){
            static const char *io_value_error_msg = "IO value mask is missing";
            error = io_value_error_msg;
            printf("[Config Request] Error: %s\r\n", io_value_error_msg);
            goto config_response_error;
        }else{
            uint8_t io_value_mask = bpio_ConfigurationRequest_io_value_mask_get(config_request);
            uint8_t io_value = bpio_ConfigurationRequest_io_value_get(config_request);
            for(uint8_t i = 0; i < 8; i++) {
                if(io_value_mask & (1u << i)) {
                    //set the value
                    gpio_put(i+8, (io_value & (1u << i)));
                    printf("[Config Request] IO%d set to %s\r\n", i, (io_value & (1u << i)) ? "high" : "low");
                }
            }
        }        
    }

    //led_resume
    if(bpio_ConfigurationRequest_led_resume_is_present(config_request)) {
        bool led_resume = bpio_ConfigurationRequest_led_resume_get(config_request);
        if (led_resume) {
            printf("[Config Request] LED effect resumed\r\n");
            rgb_irq_enable(true); // Enable the RGB IRQ
        } else {
            printf("[Config Request] LED effect paused\r\n");
            rgb_irq_enable(false); // Disable the RGB IRQ
        }
    }

    //led_color
    if(bpio_ConfigurationRequest_led_color_is_present(config_request)) {
        flatbuffers_uint32_vec_t led_color = bpio_ConfigurationRequest_led_color_get(config_request);
        if(flatbuffers_uint32_vec_len(led_color) < RGB_LEN) {
            static const char *led_error_msg = "LED color vector (array) too short";
            printf("[Config Request] Error: %s: %d, this device has %d LEDs\r\n", led_error_msg, flatbuffers_uint32_vec_len(led_color), RGB_LEN);
            error = led_error_msg;
            goto config_response_error;
        }else{
            uint32_t colors[RGB_LEN];
            printf("[Config Request] LED colors: ");
            for (size_t i = 0; i < RGB_LEN; i++) {
                colors[i] = flatbuffers_uint32_vec_at(led_color, i);
                printf("0x%06X ", colors[i]);
            }
            printf("\r\n");
            rgb_irq_enable(false);
            rgb_set_array(colors);            
        }
    }

config_response_error:
    bpio_ConfigurationResponse_start(B);
    // If there was an error, we can set it here.
    if (error) {
        // Set the error message in the response.
        flatbuffers_string_ref_t error_str = flatbuffers_string_create_str(B, error);
        bpio_ConfigurationResponse_error_add(B, error_str);
        printf("%s\r\n", error);
    }
    bpio_ConfigurationResponse_ref_t config_response = bpio_ConfigurationResponse_end(B);
    
    // add to packet wrapper
    bpio_ResponsePacket_start_as_root(B);
    bpio_ResponsePacket_contents_ConfigurationResponse_add(B, config_response);
    bpio_ResponsePacket_end_as_root(B);            
    // send the packet
    send_packet(B);
}

uint32_t data_request(bpio_RequestPacket_table_t packet, flatcc_builder_t *B) {
    bpio_DataRequest_table_t data_request = (bpio_DataRequest_table_t) bpio_RequestPacket_contents(packet);
    test_assert(data_request != 0);

    /*table DataRequest {
  start_main:bool; // Start condition.
  start_alt:bool; // Alternate start condition.
  i2c_addr:ubyte; // Device address (Bus Pirate automatically will set read/write bit)
  data_write:[ubyte]; // Data to write
  bytes_read:uint16; // Number of bytes to read.
  stop_main:bool; // Stop condition.
  stop_alt:bool; // Alternate stop condition.
}*/
    const char *error = NULL;

    //check if each field is present, get value
    bool start_main = false;
    if(bpio_DataRequest_start_main_is_present(data_request)) {
        start_main = bpio_DataRequest_start_main(data_request);
    }
    printf("Start main condition: %s\r\n", start_main ? "true" : "false");

    // Check if start_alt is present and get its value.
    bool start_alt = false;
    if(bpio_DataRequest_start_alt_is_present(data_request)) {
        start_alt = bpio_DataRequest_start_alt(data_request);
    }
    printf("Start alternate condition: %s\r\n", start_alt ? "true" : "false");

    // Check if i2c_addr is present and get its value.
    uint8_t i2c_addr = 0;
    bool i2c_addr_present = false;
    if(bpio_DataRequest_i2c_addr_is_present(data_request)) {
        i2c_addr = bpio_DataRequest_i2c_addr(data_request);
        i2c_addr_present = true;
    }  
    if (i2c_addr_present) {
        printf("I2C Address: 0x%02X\r\n", i2c_addr);
    } else {
        printf("I2C Address is not present\r\n");
    }
    
    // Check if data_write is present and get its value.
    flatbuffers_uint8_vec_t data_write = 0;
    uint32_t data_write_len = 0;
    if(bpio_DataRequest_data_write_is_present(data_request)) {
        data_write = bpio_DataRequest_data_write(data_request);
        data_write_len = flatbuffers_uint8_vec_len(data_write);
        printf("Data write vector is present\r\n");
    }else{
        printf("Data write vector is missing\r\n");
    }
    if (data_write > 0) {
        printf("Data write vector length: %d\r\n", data_write_len);
        // Print the data write vector contents.
        printf("Data write: ");
        for (size_t i = 0; i < data_write_len; i++) {
            printf("0x%02X ", flatbuffers_uint8_vec_at(data_write, i));
        }
        printf("\r\n");
    }

    // Check if bytes_read is present and get its value.
    uint16_t readbytes = 0;
    if(bpio_DataRequest_bytes_read_is_present(data_request)) {
        readbytes = bpio_DataRequest_bytes_read(data_request);
    }
    printf("Bytes to read: %d\r\n", readbytes);

    // Check if stop_main is present and get its value.
    bool stop_main = false;
    if(bpio_DataRequest_stop_main_is_present(data_request)) {
        stop_main = bpio_DataRequest_stop_main(data_request);
    }
    printf("Stop main condition: %s\r\n", stop_main ? "true" : "false");

    // Check if stop_alt is present and get its value.
    bool stop_alt = false;
    if(bpio_DataRequest_stop_alt_is_present(data_request)) {
        stop_alt = bpio_DataRequest_stop_alt(data_request);
    }
    printf("Stop alternate condition: %s\r\n", stop_alt ? "true" : "false");

    //print summary of the request
    printf("start_main: %s, start_alt: %s, i2c_addr: 0x%02X, data_write_len: %d, readbytes: %d, stop_main: %s, stop_alt: %s\r\n",
            start_main ? "true" : "false", start_alt ? "true" : "false", i2c_addr, data_write_len, readbytes,
            stop_main ? "true" : "false", stop_alt ? "true" : "false");


    // Now we can process the request.
    // For example, we can send the data to the device.
    // Here we would typically send the data to the device using the Bus Pirate's I2C interface.

    //prepare DataResponse, put mock up data in data_read if readbytes > 0
    bpio_DataResponse_start(B);
    if (readbytes > 0) {
        // Create a vector for the data read.
        bpio_DataResponse_data_read_start(B);
        uint8_t temp = 0xff;
        for (uint16_t i = 0; i < readbytes; i++) {
            bpio_DataResponse_data_read_push(B, &temp); // Mock data, replace with actual read data.
        }
        bpio_DataResponse_data_read_end(B);
    }
    static const char *error_msg = "Test error"; // Placeholder for error message.
    error = error_msg; // Set a default error message for now.
    if (error) {
        // Set the error message in the response.
        flatbuffers_string_ref_t error_str = flatbuffers_string_create_str(B, error_msg);
        bpio_DataResponse_error_add(B, error_str);
        printf("%s\r\n", error_msg);
    }
    bpio_DataResponse_ref_t data_response = bpio_DataResponse_end(B);
    // add to packet wrapper
    bpio_ResponsePacket_start_as_root(B);
    bpio_ResponsePacket_contents_DataResponse_add(B, data_response);
    bpio_ResponsePacket_end_as_root(B);
       
    // send the packet
    uint8_t* buf;
    size_t len = flatcc_builder_get_buffer_size(B);
    buf = flatcc_builder_finalize_buffer(B, &len);
    printf("Sending DataResponse packet with length %d\r\n", len);
    //send two byte length header
    uint8_t header[2];
    header[0] = len & 0xFF; // LSB
    header[1] = (len >> 8) & 0xFF; // MSB
    bin_tx_fifo_put(header[0]);
    bin_tx_fifo_put(header[1]);
    for(size_t i = 0; i < len; i++) {
        bin_tx_fifo_put(buf[i]);
    }   
}

struct _bpio_function_t {
    uint32_t (*func)(bpio_RequestPacket_table_t packet, flatcc_builder_t *B);
};

const static struct _bpio_function_t bpio_handlers[]={
    [bpio_RequestPacketContents_NONE] = { .func = NULL }, // No handler for unknown packets
    [bpio_RequestPacketContents_StatusRequest] = { .func = status_request },
    [bpio_RequestPacketContents_ConfigurationRequest] = { .func = configuration_request },
    [bpio_RequestPacketContents_DataRequest] = { .func = data_request },
};

// handler needs to be cooperative multitasking until mode is enabled
void dirtyproto_mode(void) {
    binmode_debug = true;
    static uint8_t binmode_state = BINMODE_IDLE;

    uint8_t buf[500];
    static uint32_t len=0;
    char c; 
    
    if (!bin_rx_fifo_try_get(&c)) return;

    switch (binmode_state) {
        case BINMODE_IDLE:
            len=c;
            binmode_state = BINMODE_HEADER1;
            break;
        case BINMODE_HEADER1:
            len |= c << 8;
            if(len==0 || len>sizeof(buf)){ //TODO: on all fails return error response
                printf("[BPIO] Flatbuffer size error: %d\r\n", len);
                binmode_state = BINMODE_IDLE;
                break;
            }
            printf("[BPIO] Flatbuffer length: %d\r\n", len);         
            binmode_state = BINMODE_PACKET;
            //break;
        case BINMODE_PACKET:
            //get len bytes
            for(uint32_t i=0; i<len; i++) {
                bin_rx_fifo_get_blocking(&c);
                buf[i] = c; // Store in reverse order
            }
            printf("[BPIO] Flatbuffer received, length: %d\r\n", len);
            bpio_RequestPacket_table_t packet = bpio_RequestPacket_as_root(buf);
            if(packet == 0) {
                printf("[BPIO] Error: Invalid packet received\r\n");
                binmode_state = BINMODE_IDLE; // Reset state on error
                return;
            }
            uint8_t packet_type = bpio_RequestPacket_contents_type_get(packet);
            printf("[BPIO] Packet Type: %d\r\n", packet_type);
            if (packet_type < count_of(bpio_handlers) && bpio_handlers[packet_type].func) {
                // build response    
                flatcc_builder_t builder, *B;
                B = &builder;
                flatcc_builder_init(B);
                // Call the handler function for this packet type.
                bpio_handlers[packet_type].func(packet, B);
                //flatcc_builder_reset(B);
                // build next buffer.
                // ...
                // Cleanup.
                flatcc_builder_clear(B);    
            } else {
                printf("[BPIO] Unknown packet type: %d\r\n", packet_type);
            }
            binmode_state = BINMODE_IDLE; // Reset state after processing the packet
            break;
        default:
            printf("[BPIO] Unknown binmode state: %d\r\n", binmode_state);
            binmode_state = BINMODE_IDLE;
            break;
    }

}
